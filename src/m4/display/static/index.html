<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>M4 Display</title>
<style>
  :root {
    --bg: #ffffff;
    --bg-card: #f8f9fa;
    --bg-header: #f0f1f3;
    --text: #1a1a2e;
    --text-muted: #6c757d;
    --border: #dee2e6;
    --accent: #4361ee;
    --accent-hover: #3a56d4;
    --success: #2ec4b6;
    --error: #e63946;
    --warning: #ffc107;
    --font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
    --mono: 'SF Mono', 'Fira Code', 'Fira Mono', Menlo, Consolas, monospace;
    --radius: 8px;
    --shadow: 0 1px 3px rgba(0,0,0,0.08);
    --pin-color: #f59e0b;
  }

  [data-theme="dark"] {
    --bg: #1a1b26;
    --bg-card: #24253a;
    --bg-header: #1e1f32;
    --text: #c0caf5;
    --text-muted: #7982a9;
    --border: #33354a;
    --accent: #7aa2f7;
    --accent-hover: #89b4fa;
    --success: #9ece6a;
    --error: #f7768e;
    --warning: #e0af68;
    --shadow: 0 1px 3px rgba(0,0,0,0.3);
    --pin-color: #e0af68;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: var(--font);
    background: var(--bg);
    color: var(--text);
    line-height: 1.5;
    transition: background 0.2s, color 0.2s;
  }

  /* Header */
  .header {
    position: sticky;
    top: 0;
    z-index: 100;
    background: var(--bg);
    border-bottom: 1px solid var(--border);
    padding: 10px 24px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    transition: background 0.2s, border-color 0.2s;
  }

  .header-left {
    display: flex;
    align-items: center;
    gap: 16px;
  }

  .header h1 {
    font-size: 15px;
    font-weight: 600;
    letter-spacing: -0.3px;
  }

  /* Run History Dropdown */
  .run-dropdown {
    position: relative;
    display: inline-block;
  }

  .run-dropdown-trigger {
    padding: 5px 10px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--bg);
    color: var(--text);
    font-size: 12px;
    font-family: var(--font);
    cursor: pointer;
    outline: none;
    transition: border-color 0.15s, background 0.15s;
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }

  .run-dropdown-trigger:hover { border-color: var(--accent); }
  .run-dropdown-trigger.open { border-color: var(--accent); background: var(--bg-card); }

  .run-dropdown-trigger .dd-arrow {
    font-size: 10px;
    color: var(--text-muted);
    transition: transform 0.15s;
  }

  .run-dropdown-trigger.open .dd-arrow { transform: rotate(180deg); }

  .run-dropdown-panel {
    position: absolute;
    top: calc(100% + 4px);
    left: 0;
    z-index: 110;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    box-shadow: 0 4px 16px rgba(0,0,0,0.12);
    min-width: 300px;
    max-width: 380px;
    max-height: 420px;
    overflow-y: auto;
    animation: fadeIn 0.15s ease;
  }

  .run-dropdown-all {
    padding: 8px 12px;
    cursor: pointer;
    font-size: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: background 0.15s;
    border-bottom: 1px solid var(--border);
  }

  .run-dropdown-all:hover { background: var(--bg-header); }
  .run-dropdown-all.selected { font-weight: 600; color: var(--accent); }

  .run-dropdown-group-label {
    padding: 8px 12px 4px;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-muted);
  }

  .run-dropdown-entry {
    padding: 6px 12px;
    cursor: pointer;
    font-size: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: background 0.15s;
  }

  .run-dropdown-entry:hover { background: var(--bg-header); }
  .run-dropdown-entry.selected { background: var(--bg-card); }

  .run-dropdown-empty {
    padding: 16px 12px;
    font-size: 12px;
    color: var(--text-muted);
    text-align: center;
  }

  .run-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  .run-dot.active { background: var(--success); }
  .run-dot.inactive { background: transparent; border: 1px solid var(--border); }

  .run-entry-label {
    flex: 1;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .run-entry-meta {
    color: var(--text-muted);
    font-size: 11px;
    white-space: nowrap;
    flex-shrink: 0;
  }

  .run-delete-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-muted);
    font-size: 14px;
    padding: 0 2px;
    line-height: 1;
    opacity: 0;
    transition: opacity 0.15s, color 0.15s;
    flex-shrink: 0;
  }

  .run-dropdown-entry:hover .run-delete-btn { opacity: 1; }
  .run-delete-btn:hover { color: var(--error); }

  /* Run metadata bar */
  .run-metadata-bar {
    max-width: 960px;
    margin: 0 auto;
    padding: 12px 24px 0;
    display: none;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: var(--text-muted);
  }

  .run-metadata-bar.visible { display: flex; }

  .run-meta-label {
    font-weight: 600;
    color: var(--text);
  }

  .run-meta-sep {
    color: var(--border);
  }

  /* Run separator in feed (All runs view) */
  .run-separator {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 0 4px;
    font-size: 12px;
    font-weight: 600;
    color: var(--text-muted);
  }

  .run-separator::after {
    content: '';
    flex: 1;
    height: 1px;
    background: var(--border);
  }

  .run-separator.hidden-by-filter { display: none; }

  .header-actions {
    display: flex;
    gap: 6px;
    align-items: center;
  }

  .btn {
    padding: 5px 12px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--bg);
    color: var(--text);
    font-size: 12px;
    cursor: pointer;
    font-family: var(--font);
    transition: background 0.15s, border-color 0.15s, color 0.15s;
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }

  .btn:hover { background: var(--bg-header); }

  .btn-icon {
    padding: 5px 8px;
    border: none;
    background: transparent;
    color: var(--text-muted);
    cursor: pointer;
    border-radius: 4px;
    font-size: 14px;
    line-height: 1;
    transition: color 0.15s, background 0.15s;
  }

  .btn-icon:hover {
    color: var(--text);
    background: var(--bg-header);
  }

  /* Card feed */
  .feed {
    max-width: 960px;
    margin: 0 auto;
    padding: 24px;
    display: flex;
    flex-direction: column;
    gap: 16px;
    min-height: calc(100vh - 110px);
  }

  .empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    flex: 1;
    color: var(--text-muted);
    gap: 8px;
    padding: 80px 0;
  }

  .empty-state code {
    font-family: var(--mono);
    background: var(--bg-card);
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 13px;
  }

  /* Cards */
  .card {
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--bg);
    box-shadow: var(--shadow);
    overflow: hidden;
    animation: fadeIn 0.2s ease;
    transition: border-color 0.15s, box-shadow 0.15s, background 0.2s;
  }

  .card.pinned {
    border-color: var(--pin-color);
    box-shadow: 0 0 0 1px var(--pin-color), var(--shadow);
  }

  .card.hidden-by-filter { display: none; }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(8px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .card-header {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    background: var(--bg-header);
    border-bottom: 1px solid var(--border);
    font-size: 13px;
    gap: 8px;
    user-select: none;
    transition: background 0.2s, border-color 0.2s;
  }

  .card-collapse-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-muted);
    font-size: 10px;
    padding: 2px;
    line-height: 1;
    transition: transform 0.15s, color 0.15s;
    flex-shrink: 0;
  }

  .card-collapse-btn:hover { color: var(--text); }
  .card-collapse-btn.collapsed { transform: rotate(-90deg); }

  .card-title {
    font-weight: 600;
    font-size: 13px;
    flex: 1;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .card-actions {
    display: flex;
    gap: 2px;
    align-items: center;
    flex-shrink: 0;
  }

  .card-action-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-muted);
    font-size: 13px;
    padding: 3px 5px;
    border-radius: 3px;
    line-height: 1;
    transition: color 0.15s, background 0.15s;
  }

  .card-action-btn:hover {
    color: var(--text);
    background: var(--bg-card);
  }

  .card-action-btn.pinned { color: var(--pin-color); }
  .card-action-btn.copied { color: var(--success); }

  .card-meta {
    color: var(--text-muted);
    font-size: 11px;
    white-space: nowrap;
    flex-shrink: 0;
  }

  .card-body {
    padding: 16px;
    transition: background 0.2s;
  }

  .card-body.collapsed {
    display: none;
  }

  .card-provenance {
    padding: 6px 12px;
    border-top: 1px solid var(--border);
    font-size: 11px;
    color: var(--text-muted);
    font-family: var(--mono);
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    transition: border-color 0.2s;
  }

  .card-provenance.collapsed {
    display: none;
  }

  /* Table cards */
  .table-wrapper {
    overflow-x: auto;
    overflow-y: auto;
    max-height: 360px;
    font-size: 13px;
  }

  .table-wrapper table {
    width: 100%;
    border-collapse: collapse;
    font-family: var(--mono);
    font-size: 12px;
  }

  .table-wrapper th {
    text-align: left;
    padding: 7px 12px;
    border-bottom: 2px solid var(--border);
    font-weight: 600;
    white-space: nowrap;
    background: var(--bg-card);
    position: sticky;
    top: 0;
    z-index: 1;
    cursor: pointer;
    user-select: none;
    transition: background 0.15s;
  }

  .table-wrapper th:hover {
    background: var(--bg-header);
  }

  .table-wrapper th .sort-indicator {
    display: inline-block;
    margin-left: 4px;
    font-size: 10px;
    color: var(--text-muted);
    opacity: 0;
    transition: opacity 0.15s;
  }

  .table-wrapper th:hover .sort-indicator { opacity: 0.5; }
  .table-wrapper th .sort-indicator.active { opacity: 1; color: var(--accent); }

  .table-wrapper td {
    padding: 5px 12px;
    border-bottom: 1px solid var(--border);
    white-space: nowrap;
    max-width: 300px;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .table-wrapper tr:hover td {
    background: var(--bg-card);
  }

  .table-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    font-size: 12px;
    color: var(--text-muted);
  }

  .table-pager {
    display: flex;
    gap: 4px;
    align-items: center;
  }

  .table-pager button {
    padding: 3px 10px;
    border: 1px solid var(--border);
    border-radius: 4px;
    background: var(--bg);
    color: var(--text);
    cursor: pointer;
    font-size: 12px;
    font-family: var(--font);
    transition: background 0.15s;
  }

  .table-pager button:hover { background: var(--bg-header); }
  .table-pager button:disabled { opacity: 0.4; cursor: default; }

  /* Markdown cards */
  .markdown-body {
    font-size: 14px;
    line-height: 1.7;
  }

  .markdown-body h1, .markdown-body h2, .markdown-body h3 {
    margin: 16px 0 8px;
    font-weight: 600;
  }

  .markdown-body h1 { font-size: 20px; }
  .markdown-body h2 { font-size: 17px; }
  .markdown-body h3 { font-size: 15px; }
  .markdown-body p { margin: 8px 0; }
  .markdown-body strong { font-weight: 600; }

  .markdown-body code {
    font-family: var(--mono);
    background: var(--bg-card);
    padding: 1px 5px;
    border-radius: 3px;
    font-size: 13px;
  }

  .markdown-body pre {
    background: var(--bg-card);
    padding: 12px 16px;
    border-radius: 6px;
    overflow-x: auto;
    margin: 8px 0;
  }

  .markdown-body pre code {
    background: none;
    padding: 0;
  }

  .markdown-body ul, .markdown-body ol {
    padding-left: 24px;
    margin: 8px 0;
  }

  /* Key-value cards */
  .kv-list {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 4px 16px;
    font-size: 13px;
  }

  .kv-key {
    font-weight: 600;
    color: var(--text-muted);
    text-align: right;
    font-family: var(--mono);
  }

  .kv-value {
    font-family: var(--mono);
  }

  /* Section dividers */
  .section-divider {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 8px 0;
    color: var(--text-muted);
    font-size: 13px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .section-divider.hidden-by-filter { display: none; }

  .section-divider::before,
  .section-divider::after {
    content: '';
    flex: 1;
    height: 1px;
    background: var(--border);
  }

  /* Footer */
  .footer {
    position: sticky;
    bottom: 0;
    background: var(--bg);
    border-top: 1px solid var(--border);
    padding: 6px 24px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 11px;
    color: var(--text-muted);
    transition: background 0.2s, border-color 0.2s;
  }

  .status-dot {
    display: inline-block;
    width: 7px;
    height: 7px;
    border-radius: 50%;
    margin-right: 5px;
  }

  .status-connected { background: var(--success); }
  .status-disconnected { background: var(--error); }
  .status-connecting { background: var(--warning); }

  /* Plotly chart cards */
  .plotly-container {
    width: 100%;
    min-height: 300px;
    position: relative;
  }

  .plotly-container .js-plotly-plot {
    width: 100% !important;
  }

  .chart-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 200px;
    color: var(--text-muted);
    font-size: 13px;
    gap: 8px;
  }

  .chart-loading::before {
    content: '';
    width: 16px;
    height: 16px;
    border: 2px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Image cards (matplotlib SVG) */
  .image-container {
    text-align: center;
  }

  .image-container img {
    max-width: 100%;
    height: auto;
    border-radius: 4px;
  }

  /* Copy toast */
  .copy-toast {
    position: fixed;
    bottom: 48px;
    left: 50%;
    transform: translateX(-50%) translateY(8px);
    background: var(--text);
    color: var(--bg);
    padding: 6px 16px;
    border-radius: 6px;
    font-size: 12px;
    opacity: 0;
    transition: opacity 0.2s, transform 0.2s;
    pointer-events: none;
    z-index: 200;
  }

  .copy-toast.visible {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }

  /* Table toolbar (search + export) */
  .table-toolbar {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 0 4px;
  }

  .table-search {
    padding: 5px 10px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--bg);
    color: var(--text);
    font-size: 12px;
    font-family: var(--font);
    outline: none;
    flex: 1;
    max-width: 260px;
    transition: border-color 0.15s;
  }

  .table-search:focus { border-color: var(--accent); }

  .table-search::placeholder { color: var(--text-muted); }

  /* Column type badges */
  .type-badge {
    display: inline-block;
    font-size: 9px;
    font-weight: 500;
    padding: 0 4px;
    margin-left: 4px;
    border-radius: 3px;
    background: var(--bg);
    color: var(--text-muted);
    border: 1px solid var(--border);
    font-family: var(--mono);
    vertical-align: middle;
    line-height: 15px;
    letter-spacing: 0.3px;
  }

  /* Export button */
  .export-btn {
    padding: 3px 8px;
    border: 1px solid var(--border);
    border-radius: 4px;
    background: var(--bg);
    color: var(--text-muted);
    cursor: pointer;
    font-size: 11px;
    font-family: var(--font);
    transition: background 0.15s, color 0.15s;
    white-space: nowrap;
  }

  .export-btn:hover {
    background: var(--bg-header);
    color: var(--text);
  }

  /* Row detail panel */
  .row-detail-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.25);
    z-index: 150;
    animation: fadeOverlay 0.15s ease;
  }

  @keyframes fadeOverlay {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  .row-detail-panel {
    position: fixed;
    right: 0;
    top: 0;
    bottom: 0;
    width: min(480px, 90vw);
    background: var(--bg);
    border-left: 1px solid var(--border);
    box-shadow: -4px 0 16px rgba(0,0,0,0.12);
    z-index: 151;
    display: flex;
    flex-direction: column;
    animation: slideIn 0.2s ease;
  }

  @keyframes slideIn {
    from { transform: translateX(100%); }
    to { transform: translateX(0); }
  }

  .row-detail-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px;
    border-bottom: 1px solid var(--border);
    font-size: 13px;
    font-weight: 600;
  }

  .row-detail-close {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-muted);
    font-size: 18px;
    line-height: 1;
    padding: 2px 6px;
    border-radius: 4px;
    transition: color 0.15s, background 0.15s;
  }

  .row-detail-close:hover {
    color: var(--text);
    background: var(--bg-header);
  }

  .row-detail-body {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
  }

  .row-detail-body .kv-list {
    grid-template-columns: minmax(80px, auto) 1fr;
    gap: 6px 16px;
  }

  .table-wrapper tr { cursor: pointer; }

  /* Waiting card (response_requested) */
  .card.waiting {
    border-left: 3px solid var(--accent);
  }

  @keyframes subtlePulse {
    0%, 100% { box-shadow: var(--shadow); }
    50% { box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent) 20%, transparent), var(--shadow); }
  }

  .card.waiting { animation: subtlePulse 3s ease-in-out infinite; }

  /* Response UI panel */
  .card-response-ui {
    padding: 12px 16px;
    border-top: 1px solid var(--border);
    background: var(--bg-card);
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .response-prompt {
    font-size: 13px;
    font-weight: 500;
    color: var(--text);
  }

  .response-message-input {
    width: 100%;
    padding: 8px 10px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--bg);
    color: var(--text);
    font-size: 12px;
    font-family: var(--font);
    resize: vertical;
    min-height: 36px;
    max-height: 120px;
    outline: none;
    transition: border-color 0.15s;
  }

  .response-message-input:focus { border-color: var(--accent); }

  .response-actions {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .response-btn {
    padding: 6px 16px;
    border: 1px solid var(--border);
    border-radius: 6px;
    font-size: 12px;
    font-family: var(--font);
    cursor: pointer;
    transition: background 0.15s, border-color 0.15s, color 0.15s;
  }

  .response-btn-confirm {
    background: var(--accent);
    color: white;
    border-color: var(--accent);
  }

  .response-btn-confirm:hover {
    background: var(--accent-hover);
    border-color: var(--accent-hover);
  }

  .response-btn-skip {
    background: var(--bg);
    color: var(--text-muted);
  }

  .response-btn-skip:hover {
    background: var(--bg-header);
    color: var(--text);
  }

  .response-timeout {
    margin-left: auto;
    font-size: 11px;
    color: var(--text-muted);
    font-family: var(--mono);
  }

  /* Table row checkboxes for selection */
  .table-wrapper th.select-col,
  .table-wrapper td.select-col {
    width: 32px;
    text-align: center;
    padding: 5px 4px;
  }

  .table-wrapper td.select-col input[type="checkbox"],
  .table-wrapper th.select-col input[type="checkbox"] {
    cursor: pointer;
    accent-color: var(--accent);
  }

  /* Send to Agent button */
  .send-to-agent-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-muted);
    font-size: 12px;
    padding: 3px 5px;
    border-radius: 3px;
    line-height: 1;
    transition: color 0.15s, background 0.15s;
  }

  .send-to-agent-btn:hover {
    color: var(--accent);
    background: var(--bg-card);
  }

  /* Prompt popover */
  .prompt-popover {
    position: absolute;
    right: 0;
    top: 100%;
    z-index: 50;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    padding: 12px;
    width: 280px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    animation: fadeIn 0.15s ease;
  }

  .prompt-popover textarea {
    width: 100%;
    padding: 8px 10px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--bg);
    color: var(--text);
    font-size: 12px;
    font-family: var(--font);
    resize: vertical;
    min-height: 60px;
    max-height: 120px;
    outline: none;
    transition: border-color 0.15s;
  }

  .prompt-popover textarea:focus { border-color: var(--accent); }

  .prompt-popover .send-btn {
    align-self: flex-end;
    padding: 5px 14px;
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 6px;
    font-size: 12px;
    font-family: var(--font);
    cursor: pointer;
    transition: background 0.15s;
  }

  .prompt-popover .send-btn:hover { background: var(--accent-hover); }

  /* Card flash animation on update */
  @keyframes flashHighlight {
    0% { background: color-mix(in srgb, var(--accent) 15%, var(--bg)); }
    100% { background: var(--bg); }
  }

  .card.flash { animation: flashHighlight 0.6s ease; }

  /* Pending request badge */
  .request-badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-width: 18px;
    height: 18px;
    padding: 0 5px;
    border-radius: 9px;
    background: var(--accent);
    color: white;
    font-size: 10px;
    font-weight: 600;
    line-height: 1;
  }

  .request-badge.hidden { display: none; }

  /* Card updating overlay */
  .card-updating-overlay {
    position: absolute;
    inset: 0;
    background: color-mix(in srgb, var(--bg) 60%, transparent);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2;
    border-radius: var(--radius);
  }

  .card-updating-overlay::before {
    content: '';
    width: 20px;
    height: 20px;
    border: 2px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  .card { position: relative; }

  /* Sent confirmation */
  .sent-badge {
    display: inline-block;
    font-size: 11px;
    color: var(--success);
    font-weight: 500;
    padding: 2px 6px;
  }
</style>
</head>
<body>

<div class="header">
  <div class="header-left">
    <h1>M4 Display</h1>
    <div class="run-dropdown" id="run-dropdown">
      <button class="run-dropdown-trigger" id="run-dropdown-trigger" title="Browse runs">
        <span id="run-dropdown-label">All runs</span>
        <span class="dd-arrow">&#9662;</span>
      </button>
      <div class="run-dropdown-panel" id="run-dropdown-panel" style="display: none;"></div>
    </div>
  </div>
  <div class="header-actions">
    <span class="request-badge hidden" id="request-badge" title="Pending agent requests">0</span>
    <button class="btn-icon" id="theme-toggle" title="Toggle theme">&#9789;</button>
  </div>
</div>

<div class="run-metadata-bar" id="run-metadata-bar">
  <span class="run-meta-label" id="run-meta-label"></span>
  <span class="run-meta-sep">&middot;</span>
  <span id="run-meta-detail"></span>
</div>

<div class="feed" id="feed">
  <div class="empty-state" id="empty-state">
    <div style="font-size: 32px; opacity: 0.3;">&#9671;</div>
    <div style="font-size: 15px; font-weight: 500;">No analyses yet</div>
    <div style="font-size: 13px;">Run an agent to get started</div>
    <div><code>from m4.display import show</code></div>
  </div>
</div>

<div class="footer">
  <div id="status">
    <span class="status-dot status-connecting"></span>
    Connecting...
  </div>
  <div id="session-info"></div>
  <div id="card-count">0 cards</div>
</div>

<div class="copy-toast" id="copy-toast">Copied to clipboard</div>

<script>
(function() {
  'use strict';

  // --- State ---
  var state = {
    ws: null,
    cards: [],
    connected: false,
    reconnectDelay: 1000,
    reconnectTimer: null,
    markedLoaded: false,
    plotlyLoaded: false,
    plotlyCallbacks: [],
    runIds: [],
    activeRunFilter: '',
    runs: [],
    activeRunId: null,
    dropdownOpen: false,
    liveMode: false,
    _autoSelectPending: false,
  };

  // --- Elements ---
  var feed = document.getElementById('feed');
  var emptyState = document.getElementById('empty-state');
  var statusEl = document.getElementById('status');
  var sessionInfoEl = document.getElementById('session-info');
  var cardCountEl = document.getElementById('card-count');
  var themeToggleEl = document.getElementById('theme-toggle');
  var copyToastEl = document.getElementById('copy-toast');
  var runDropdownTrigger = document.getElementById('run-dropdown-trigger');
  var runDropdownPanel = document.getElementById('run-dropdown-panel');
  var runDropdownLabel = document.getElementById('run-dropdown-label');
  var runMetaBar = document.getElementById('run-metadata-bar');
  var runMetaLabel = document.getElementById('run-meta-label');
  var runMetaDetail = document.getElementById('run-meta-detail');

  // --- Theme ---
  function initTheme() {
    var saved = localStorage.getItem('m4-display-theme');
    if (saved === 'dark') {
      document.documentElement.setAttribute('data-theme', 'dark');
      themeToggleEl.innerHTML = '&#9788;';
    }
  }

  themeToggleEl.onclick = function() {
    var isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    if (isDark) {
      document.documentElement.removeAttribute('data-theme');
      localStorage.setItem('m4-display-theme', 'light');
      themeToggleEl.innerHTML = '&#9789;';
    } else {
      document.documentElement.setAttribute('data-theme', 'dark');
      localStorage.setItem('m4-display-theme', 'dark');
      themeToggleEl.innerHTML = '&#9788;';
    }
  };

  initTheme();

  // --- Run History Dropdown ---
  runDropdownTrigger.onclick = function(e) {
    e.stopPropagation();
    if (state.dropdownOpen) {
      closeDropdown();
    } else {
      openDropdown();
    }
  };

  function openDropdown() {
    state.dropdownOpen = true;
    runDropdownTrigger.classList.add('open');
    renderDropdown();
    runDropdownPanel.style.display = '';
    // Close on outside click
    setTimeout(function() {
      document.addEventListener('mousedown', _closeDropdownOutside);
    }, 0);
  }

  function closeDropdown() {
    state.dropdownOpen = false;
    runDropdownTrigger.classList.remove('open');
    runDropdownPanel.style.display = 'none';
    document.removeEventListener('mousedown', _closeDropdownOutside);
  }

  function _closeDropdownOutside(e) {
    var dd = document.getElementById('run-dropdown');
    if (dd && !dd.contains(e.target)) {
      closeDropdown();
    }
  }

  function dateGroupLabel(isoStr) {
    if (!isoStr) return 'Unknown';
    var d = new Date(isoStr);
    var today = new Date();
    today.setHours(0, 0, 0, 0);
    var yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    var dDate = new Date(d);
    dDate.setHours(0, 0, 0, 0);

    if (dDate.getTime() === today.getTime()) return 'Today';
    if (dDate.getTime() === yesterday.getTime()) return 'Yesterday';
    return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
  }

  function formatRunTime(isoStr) {
    if (!isoStr) return '';
    var d = new Date(isoStr);
    return d.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
  }

  function renderDropdown() {
    runDropdownPanel.innerHTML = '';

    // "All runs" option
    var allOpt = document.createElement('div');
    allOpt.className = 'run-dropdown-all' + (!state.activeRunFilter ? ' selected' : '');
    allOpt.textContent = 'All runs';
    allOpt.onclick = function(e) {
      e.stopPropagation();
      selectRun('');
    };
    runDropdownPanel.appendChild(allOpt);

    if (state.runs.length === 0) {
      var emptyMsg = document.createElement('div');
      emptyMsg.className = 'run-dropdown-empty';
      emptyMsg.textContent = 'No runs yet';
      runDropdownPanel.appendChild(emptyMsg);
      return;
    }

    // Group runs by date
    var groupOrder = [];
    var groups = {};
    state.runs.forEach(function(run) {
      var gl = dateGroupLabel(run.start_time);
      if (!groups[gl]) {
        groups[gl] = [];
        groupOrder.push(gl);
      }
      groups[gl].push(run);
    });

    groupOrder.forEach(function(groupLabel) {
      var gh = document.createElement('div');
      gh.className = 'run-dropdown-group-label';
      gh.textContent = groupLabel;
      runDropdownPanel.appendChild(gh);

      groups[groupLabel].forEach(function(run) {
        var entry = document.createElement('div');
        entry.className = 'run-dropdown-entry' + (state.activeRunFilter === run.label ? ' selected' : '');

        var dot = document.createElement('span');
        dot.className = 'run-dot ' + (state.activeRunId === run.label ? 'active' : 'inactive');
        entry.appendChild(dot);

        var labelEl = document.createElement('span');
        labelEl.className = 'run-entry-label';
        labelEl.textContent = run.label;
        entry.appendChild(labelEl);

        var meta = document.createElement('span');
        meta.className = 'run-entry-meta';
        meta.textContent = (run.card_count || 0) + ' cards';
        if (run.start_time) meta.textContent += '  ' + formatRunTime(run.start_time);
        entry.appendChild(meta);

        var delBtn = document.createElement('button');
        delBtn.type = 'button';
        delBtn.className = 'run-delete-btn';
        delBtn.innerHTML = '&times;';
        delBtn.title = 'Delete run';
        delBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          e.preventDefault();
          deleteRun(run.label);
        });
        entry.appendChild(delBtn);

        entry.onclick = function(e) {
          e.stopPropagation();
          selectRun(run.label);
        };
        runDropdownPanel.appendChild(entry);
      });
    });
  }

  function selectRun(label) {
    state.activeRunFilter = label;
    closeDropdown();
    updateDropdownTrigger();
    applyRunFilter();
    updateRunMetadataBar();
  }

  function updateDropdownTrigger() {
    if (state.activeRunFilter) {
      runDropdownLabel.textContent = state.activeRunFilter;
    } else {
      runDropdownLabel.textContent = 'All runs';
    }
  }

  function updateRunMetadataBar() {
    if (!state.activeRunFilter) {
      runMetaBar.classList.remove('visible');
      return;
    }
    var run = null;
    for (var i = 0; i < state.runs.length; i++) {
      if (state.runs[i].label === state.activeRunFilter) {
        run = state.runs[i];
        break;
      }
    }
    if (!run) {
      runMetaBar.classList.remove('visible');
      return;
    }
    runMetaLabel.textContent = run.label;
    var parts = [];
    if (run.card_count !== undefined) parts.push(run.card_count + ' card' + (run.card_count !== 1 ? 's' : ''));
    if (run.start_time) parts.push(new Date(run.start_time).toLocaleDateString());
    runMetaDetail.textContent = parts.join(' \u00b7 ');
    runMetaBar.classList.add('visible');
  }

  function deleteRun(label) {
    if (!confirm('Delete run "' + label + '"? This cannot be undone.')) return;
    closeDropdown();
    fetch('/api/runs/' + encodeURIComponent(label), { method: 'DELETE' })
      .then(function(r) {
        if (!r.ok) throw new Error('Server returned ' + r.status);
        return r.json();
      })
      .then(function(data) {
        if (data.status === 'ok') {
          // Remove from local state
          state.runs = state.runs.filter(function(r) { return r.label !== label; });
          state.runIds = state.runIds.filter(function(id) { return id !== label; });
          // Remove cards from DOM
          var cards = feed.querySelectorAll('.card[data-run-id="' + label + '"], .section-divider[data-run-id="' + label + '"], .run-separator[data-run-separator="' + label + '"]');
          cards.forEach(function(el) { el.remove(); });
          state.cards = state.cards.filter(function(c) { return c.run_id !== label; });
          // If this was the selected run, switch to "All runs"
          if (state.activeRunFilter === label) {
            selectRun('');
          } else {
            renderDropdown();
          }
          updateCardCount();
          showToast('Run deleted');
          // Show empty state if no cards left
          if (state.cards.length === 0) showEmptyState();
        } else {
          showToast(data.error || 'Delete failed');
        }
      })
      .catch(function(err) {
        console.error('Delete run error:', err);
        showToast('Failed to delete run');
      });
  }

  function trackRunId(runId) {
    if (!runId || state.runIds.indexOf(runId) !== -1) return;
    state.runIds.push(runId);
  }

  function insertRunSeparators() {
    // Remove existing separators
    feed.querySelectorAll('.run-separator').forEach(function(el) { el.remove(); });

    var items = feed.querySelectorAll('.card, .section-divider');
    var lastRunId = null;

    items.forEach(function(el) {
      var runId = el.dataset.runId || '';
      if (runId && runId !== lastRunId) {
        var run = null;
        for (var i = 0; i < state.runs.length; i++) {
          if (state.runs[i].label === runId) { run = state.runs[i]; break; }
        }
        var sep = document.createElement('div');
        sep.className = 'run-separator';
        sep.dataset.runSeparator = runId;
        var text = runId;
        if (run && run.start_time) text += ' \u00b7 ' + dateGroupLabel(run.start_time) + ' ' + formatRunTime(run.start_time);
        if (run && run.card_count) text += ' \u00b7 ' + run.card_count + ' cards';
        sep.textContent = text;
        el.parentNode.insertBefore(sep, el);
        lastRunId = runId;
      } else if (runId) {
        lastRunId = runId;
      }
    });
  }

  function applyRunFilter() {
    var filter = state.activeRunFilter;

    // Remove existing run separators first
    feed.querySelectorAll('.run-separator').forEach(function(el) { el.remove(); });

    var items = feed.querySelectorAll('.card, .section-divider');

    if (!filter) {
      // "All runs" mode: show everything, add run separators
      items.forEach(function(el) { el.classList.remove('hidden-by-filter'); });
      if (items.length > 0) insertRunSeparators();
    } else {
      // Specific run: show matching cards only
      items.forEach(function(el) {
        var elRun = el.dataset.runId || '';
        if (elRun === filter || !elRun) {
          el.classList.remove('hidden-by-filter');
        } else {
          el.classList.add('hidden-by-filter');
        }
      });
    }

    updateCardCount();
  }

  // --- WebSocket ---
  function connect() {
    if (state.reconnectTimer) {
      clearTimeout(state.reconnectTimer);
      state.reconnectTimer = null;
    }
    updateStatus('connecting');

    var protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
    var ws;
    try {
      ws = new WebSocket(protocol + '//' + location.host + '/ws');
    } catch (e) {
      scheduleReconnect();
      return;
    }

    ws.onopen = function() {
      state.ws = ws;
      state.connected = true;
      state.reconnectDelay = 1000;
      state.liveMode = false;
      updateStatus('connected');
      loadSessionInfo();
      loadRuns();
      // After replay completes (~500ms), enable live auto-switching
      setTimeout(function() { state.liveMode = true; }, 500);
    };

    ws.onmessage = function(event) {
      try {
        var msg = JSON.parse(event.data);
        handleMessage(msg);
      } catch (e) {
        console.error('Failed to parse message:', e);
      }
    };

    ws.onclose = function() {
      state.connected = false;
      state.ws = null;
      updateStatus('disconnected');
      scheduleReconnect();
    };

    ws.onerror = function() {
      ws.close();
    };
  }

  function scheduleReconnect() {
    state.reconnectTimer = setTimeout(connect, state.reconnectDelay);
    state.reconnectDelay = Math.min(state.reconnectDelay * 2, 15000);
  }

  function handleMessage(msg) {
    switch (msg.type) {
      case 'display.add':
        addCard(msg.card);
        break;
      case 'display.section':
        addSection(msg.title, msg.run_id);
        break;
      case 'display.update':
        updateCard(msg.card_id, msg.card);
        break;
    }
  }

  // --- Card Rendering ---
  function addCard(cardData) {
    // Remove empty state if present
    var empty = document.getElementById('empty-state');
    if (empty && empty.parentNode) {
      empty.remove();
    }

    // Deduplicate on reconnect replay
    var existing = document.getElementById('card-' + cardData.card_id);
    if (existing) return;

    state.cards.push(cardData);
    trackRunId(cardData.run_id);

    // Track active run and auto-switch
    if (cardData.run_id) {
      state.activeRunId = cardData.run_id;
      if (state.liveMode && state.activeRunFilter !== cardData.run_id) {
        // Auto-switch to the new card's run
        state.activeRunFilter = cardData.run_id;
        updateDropdownTrigger();
        // Defer full filter update to batch rapid arrivals
        if (!state._autoSelectPending) {
          state._autoSelectPending = true;
          requestAnimationFrame(function() {
            state._autoSelectPending = false;
            applyRunFilter();
            updateRunMetadataBar();
            // Refresh run list to get updated card counts
            loadRuns();
          });
        }
      }
    }

    var el = document.createElement('div');
    el.className = 'card';
    if (cardData.pinned) el.className += ' pinned';
    el.id = 'card-' + cardData.card_id;
    el.dataset.runId = cardData.run_id || '';
    el.dataset.cardId = cardData.card_id;

    // Header
    var header = document.createElement('div');
    header.className = 'card-header';

    // Collapse toggle
    var collapseBtn = document.createElement('button');
    collapseBtn.className = 'card-collapse-btn';
    collapseBtn.innerHTML = '&#9660;';
    collapseBtn.title = 'Collapse';
    collapseBtn.onclick = function() {
      var body = el.querySelector('.card-body');
      var prov = el.querySelector('.card-provenance');
      var isCollapsed = collapseBtn.classList.toggle('collapsed');
      if (body) body.classList.toggle('collapsed', isCollapsed);
      if (prov) prov.classList.toggle('collapsed', isCollapsed);
      collapseBtn.title = isCollapsed ? 'Expand' : 'Collapse';
    };
    header.appendChild(collapseBtn);

    // Title
    var title = document.createElement('span');
    title.className = 'card-title';
    title.textContent = cardData.title || cardData.card_type;
    header.appendChild(title);

    // Timestamp
    var meta = document.createElement('span');
    meta.className = 'card-meta';
    if (cardData.timestamp) {
      meta.textContent = new Date(cardData.timestamp).toLocaleTimeString();
    }
    header.appendChild(meta);

    // Action buttons
    var actions = document.createElement('div');
    actions.className = 'card-actions';

    // Copy button
    var copyBtn = document.createElement('button');
    copyBtn.className = 'card-action-btn';
    copyBtn.innerHTML = '&#128203;';
    copyBtn.title = 'Copy content';
    copyBtn.onclick = function(e) {
      e.stopPropagation();
      copyCardContent(cardData, copyBtn);
    };
    actions.appendChild(copyBtn);

    // Send to Agent button
    var sendBtn = document.createElement('button');
    sendBtn.className = 'send-to-agent-btn';
    sendBtn.innerHTML = '&#9993;';
    sendBtn.title = 'Send to Agent';
    sendBtn.onclick = function(e) {
      e.stopPropagation();
      togglePromptPopover(sendBtn, cardData, el);
    };
    actions.appendChild(sendBtn);

    // Pin button
    var pinBtn = document.createElement('button');
    pinBtn.className = 'card-action-btn' + (cardData.pinned ? ' pinned' : '');
    pinBtn.innerHTML = '&#128204;';
    pinBtn.title = cardData.pinned ? 'Unpin' : 'Pin';
    pinBtn.onclick = function(e) {
      e.stopPropagation();
      cardData.pinned = !cardData.pinned;
      pinBtn.classList.toggle('pinned', cardData.pinned);
      el.classList.toggle('pinned', cardData.pinned);
      el.dataset.pinned = cardData.pinned ? 'true' : 'false';
      pinBtn.title = cardData.pinned ? 'Unpin' : 'Pin';
    };
    actions.appendChild(pinBtn);

    header.appendChild(actions);
    el.appendChild(header);

    // Body
    var body = document.createElement('div');
    body.className = 'card-body';

    switch (cardData.card_type) {
      case 'table':
        renderTable(body, cardData);
        break;
      case 'plotly':
        renderPlotly(body, cardData);
        break;
      case 'image':
        renderImage(body, cardData);
        break;
      case 'markdown':
        renderMarkdown(body, cardData);
        break;
      case 'keyvalue':
        renderKeyValue(body, cardData);
        break;
      case 'section':
        el.remove();
        addSection(cardData.title || (cardData.preview && cardData.preview.title) || '');
        return;
      default:
        body.textContent = JSON.stringify(cardData.preview);
    }

    el.appendChild(body);

    // Waiting card: response UI
    if (cardData.response_requested) {
      el.classList.add('waiting');
      var responseUI = buildResponseUI(cardData, el);
      el.appendChild(responseUI);
    }

    // Provenance
    if (cardData.provenance) {
      var prov = document.createElement('div');
      prov.className = 'card-provenance';
      var parts = [];
      if (cardData.provenance.source) parts.push(cardData.provenance.source);
      if (cardData.provenance.dataset) parts.push(cardData.provenance.dataset);
      if (cardData.provenance.timestamp) {
        parts.push(new Date(cardData.provenance.timestamp).toLocaleString());
      }
      prov.textContent = parts.join(' \u00b7 ');
      if (parts.length > 0) el.appendChild(prov);
    }

    feed.appendChild(el);

    // Apply run filter to the new card
    if (state.activeRunFilter) {
      var cardRun = cardData.run_id || '';
      if (cardRun !== state.activeRunFilter && cardRun) {
        el.classList.add('hidden-by-filter');
      }
    }

    updateCardCount();
    scrollToBottom();
  }

  function copyCardContent(cardData, btn) {
    var text = '';
    if (cardData.card_type === 'markdown') {
      text = (cardData.preview && cardData.preview.text) || '';
    } else if (cardData.card_type === 'keyvalue') {
      var items = (cardData.preview && cardData.preview.items) || {};
      text = Object.keys(items).map(function(k) { return k + ': ' + items[k]; }).join('\n');
    } else if (cardData.card_type === 'table') {
      var p = cardData.preview;
      if (p && p.columns) {
        text = p.columns.join('\t') + '\n';
        (p.preview_rows || []).forEach(function(row) {
          text += row.map(function(v) { return v === null ? '' : String(v); }).join('\t') + '\n';
        });
      }
    } else if (cardData.card_type === 'plotly') {
      text = JSON.stringify(cardData.preview && cardData.preview.spec, null, 2);
    } else if (cardData.card_type === 'image') {
      // For images, copy the artifact URL so it can be opened/embedded
      text = cardData.artifact_id
        ? location.origin + '/api/artifact/' + cardData.artifact_id
        : '(no artifact)';
    } else {
      text = JSON.stringify(cardData.preview, null, 2);
    }

    navigator.clipboard.writeText(text).then(function() {
      btn.classList.add('copied');
      btn.innerHTML = '&#10003;';
      showToast('Copied to clipboard');
      setTimeout(function() {
        btn.classList.remove('copied');
        btn.innerHTML = '&#128203;';
      }, 1500);
    }).catch(function() {});
  }

  function showToast(msg) {
    copyToastEl.textContent = msg;
    copyToastEl.classList.add('visible');
    setTimeout(function() {
      copyToastEl.classList.remove('visible');
    }, 1500);
  }

  function mapDtypeLabel(dtype) {
    if (!dtype) return '';
    var d = dtype.toLowerCase();
    if (d.match(/^int/)) return 'int';
    if (d.match(/^float|^double|^decimal|^numeric/)) return 'float';
    if (d.match(/^bool/)) return 'bool';
    if (d.match(/^date|^time|^timestamp/)) return 'date';
    if (d.match(/^varchar|^text|^string|^utf|^object/)) return 'str';
    return dtype.split(/[^a-zA-Z]/)[0].toLowerCase().substring(0, 5);
  }

  function renderTable(container, cardData) {
    var preview = cardData.preview;
    if (!preview || !preview.columns) return;

    // Shared state for this table
    var sortState = { col: null, asc: true };
    var pagerState = { offset: 0, limit: 50 };
    var searchState = { text: '' };
    var shape = preview.shape || [0, 0];
    var totalRowsRef = { value: shape[0] };
    var rowInfoEl = document.createElement('span');
    var pagerEl = { current: null };

    function updateRowInfo() {
      var total = totalRowsRef.value;
      var start = total > 0 ? pagerState.offset + 1 : 0;
      var end = Math.min(pagerState.offset + pagerState.limit, total);
      var text = shape[1] + ' columns \u00b7 ' + total.toLocaleString() + ' rows';
      if (searchState.text) text += ' (filtered)';
      if (total > 0 && (start > 1 || end < total)) text += ' (showing ' + start + '\u2013' + end + ')';
      rowInfoEl.textContent = text;
    }

    // --- Toolbar (search + export) ---
    var toolbar = document.createElement('div');
    toolbar.className = 'table-toolbar';

    if (cardData.artifact_id) {
      var searchInput = document.createElement('input');
      searchInput.type = 'text';
      searchInput.className = 'table-search';
      searchInput.placeholder = 'Search rows...';
      var debounceTimer = null;
      searchInput.oninput = function() {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(function() {
          searchState.text = searchInput.value;
          pagerState.offset = 0;
          reloadTable(cardData.artifact_id, pagerState, sortState, searchState, wrapper, preview.columns, preview.dtypes, totalRowsRef, rowInfoEl, pagerEl, updateRowInfo);
        }, 300);
      };
      toolbar.appendChild(searchInput);

      var exportCsvBtn = document.createElement('button');
      exportCsvBtn.className = 'export-btn';
      exportCsvBtn.textContent = 'Export CSV';
      exportCsvBtn.onclick = function() {
        var url = '/api/table/' + cardData.artifact_id + '/export?format=csv';
        if (sortState.col) url += '&sort=' + encodeURIComponent(sortState.col) + '&asc=' + sortState.asc;
        if (searchState.text) url += '&search=' + encodeURIComponent(searchState.text);
        window.location = url;
      };
      toolbar.appendChild(exportCsvBtn);

      var copyTsvBtn = document.createElement('button');
      copyTsvBtn.className = 'export-btn';
      copyTsvBtn.textContent = 'Copy TSV';
      copyTsvBtn.onclick = function() {
        var tbody = wrapper.querySelector('tbody');
        var headerCells = wrapper.querySelectorAll('thead th');
        var headers = [];
        headerCells.forEach(function(th) {
          // Get just the column name text (not the sort indicator or type badge)
          headers.push(th.firstChild.textContent);
        });
        var lines = [headers.join('\t')];
        var bodyRows = tbody.querySelectorAll('tr');
        bodyRows.forEach(function(tr) {
          var cells = [];
          tr.querySelectorAll('td').forEach(function(td) { cells.push(td.textContent); });
          lines.push(cells.join('\t'));
        });
        navigator.clipboard.writeText(lines.join('\n')).then(function() {
          showToast('Copied TSV to clipboard');
        }).catch(function() {});
      };
      toolbar.appendChild(copyTsvBtn);
    }

    container.appendChild(toolbar);

    // --- Table ---
    var wrapper = document.createElement('div');
    wrapper.className = 'table-wrapper';

    var table = document.createElement('table');
    var thead = document.createElement('thead');
    var headerRow = document.createElement('tr');

    // Add select-all checkbox column for waiting cards
    if (cardData.response_requested) {
      var selectAllTh = document.createElement('th');
      selectAllTh.className = 'select-col';
      var selectAllCb = document.createElement('input');
      selectAllCb.type = 'checkbox';
      selectAllCb.title = 'Select all';
      selectAllCb.onchange = function() {
        var cbs = wrapper.querySelectorAll('tbody .select-col input[type="checkbox"]');
        cbs.forEach(function(cb) { cb.checked = selectAllCb.checked; });
      };
      selectAllTh.appendChild(selectAllCb);
      headerRow.appendChild(selectAllTh);
    }

    preview.columns.forEach(function(col) {
      var th = document.createElement('th');
      var isNumeric = false;
      if (preview.dtypes) {
        var dtype = preview.dtypes[col] || '';
        if (dtype.match(/int|float|num/i)) {
          th.style.textAlign = 'right';
          isNumeric = true;
        }
      }

      var label = document.createTextNode(col);
      th.appendChild(label);

      // Type badge
      if (preview.dtypes && preview.dtypes[col]) {
        var badge = document.createElement('span');
        badge.className = 'type-badge';
        badge.textContent = mapDtypeLabel(preview.dtypes[col]);
        th.appendChild(badge);
      }

      var indicator = document.createElement('span');
      indicator.className = 'sort-indicator';
      indicator.textContent = '\u2195';
      th.appendChild(indicator);

      if (cardData.artifact_id) {
        th.onclick = function() {
          if (sortState.col === col) {
            sortState.asc = !sortState.asc;
          } else {
            sortState.col = col;
            sortState.asc = true;
          }
          headerRow.querySelectorAll('.sort-indicator').forEach(function(ind) {
            ind.classList.remove('active');
            ind.textContent = '\u2195';
          });
          indicator.classList.add('active');
          indicator.textContent = sortState.asc ? '\u25b2' : '\u25bc';
          pagerState.offset = 0;
          reloadTable(cardData.artifact_id, pagerState, sortState, searchState, wrapper, preview.columns, preview.dtypes, totalRowsRef, rowInfoEl, pagerEl, updateRowInfo);
        };
      }

      headerRow.appendChild(th);
    });

    thead.appendChild(headerRow);
    table.appendChild(thead);

    var tbody = document.createElement('tbody');
    var rows = preview.preview_rows || [];
    renderTableRows(tbody, rows, preview.columns, preview.dtypes, cardData);

    table.appendChild(tbody);
    wrapper.appendChild(table);

    // --- Table info & pagination ---
    var totalRows = totalRowsRef.value;
    var previewCount = rows.length;

    var info = document.createElement('div');
    info.className = 'table-info';
    info.appendChild(rowInfoEl);

    if (totalRows > previewCount && cardData.artifact_id) {
      // Initial view has only preview rows  load the full first page immediately
      reloadTable(cardData.artifact_id, pagerState, sortState, searchState, wrapper, preview.columns, preview.dtypes, totalRowsRef, rowInfoEl, pagerEl, updateRowInfo);
      var pager = createPager(cardData.artifact_id, totalRowsRef, preview.columns, preview.dtypes, wrapper, rowInfoEl, pagerState, sortState, searchState, cardData, updateRowInfo);
      pagerEl.current = pager;
      info.appendChild(pager);
    } else {
      // Small table  preview is the full data
      rowInfoEl.textContent = shape[1] + ' columns \u00b7 ' + totalRows.toLocaleString() + ' rows';
    }

    container.appendChild(wrapper);
    container.appendChild(info);
  }

  function reloadTable(artifactId, pagerState, sortState, searchState, wrapper, columns, dtypes, totalRowsRef, rowInfoEl, pagerEl, updateRowInfo) {
    var url = '/api/table/' + artifactId + '?offset=' + pagerState.offset + '&limit=' + pagerState.limit;
    if (sortState && sortState.col) {
      url += '&sort=' + encodeURIComponent(sortState.col) + '&asc=' + sortState.asc;
    }
    if (searchState && searchState.text) {
      url += '&search=' + encodeURIComponent(searchState.text);
    }
    fetch(url)
      .then(function(r) { return r.json(); })
      .then(function(data) {
        totalRowsRef.value = data.total_rows;
        var tbody = wrapper.querySelector('tbody');
        // Find the parent card to get cardData for row click events
        var cardEl = wrapper.closest('.card');
        var cardData = null;
        if (cardEl) {
          var cardId = cardEl.dataset.cardId;
          cardData = state.cards.find(function(c) { return c.card_id === cardId; });
        }
        renderTableRows(tbody, data.rows, columns, dtypes, cardData);
        if (updateRowInfo) updateRowInfo();

        // Rebuild pager if needed
        if (pagerEl && pagerEl.current) {
          var parent = pagerEl.current.parentNode;
          parent.removeChild(pagerEl.current);
          var newPager = createPager(artifactId, totalRowsRef, columns, dtypes, wrapper, rowInfoEl, pagerState, sortState, searchState, cardData, updateRowInfo);
          pagerEl.current = newPager;
          parent.appendChild(newPager);
        } else if (data.total_rows > pagerState.limit) {
          var infoDiv = rowInfoEl.parentNode;
          var newPager = createPager(artifactId, totalRowsRef, columns, dtypes, wrapper, rowInfoEl, pagerState, sortState, searchState, cardData, updateRowInfo);
          pagerEl.current = newPager;
          infoDiv.appendChild(newPager);
        }
      });
  }

  function renderTableRows(tbody, rows, columns, dtypes, cardData) {
    tbody.innerHTML = '';
    var hasCheckboxes = cardData && cardData.response_requested;
    rows.forEach(function(row, rowIdx) {
      var tr = document.createElement('tr');
      // Add selection checkbox for waiting cards
      if (hasCheckboxes) {
        var selTd = document.createElement('td');
        selTd.className = 'select-col';
        var cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.onclick = function(e) { e.stopPropagation(); };
        selTd.appendChild(cb);
        tr.appendChild(selTd);
      }
      row.forEach(function(val, i) {
        var td = document.createElement('td');
        td.textContent = val === null ? '\u2014' : String(val);
        if (dtypes) {
          var dtype = dtypes[columns[i]] || '';
          if (dtype.match(/int|float|num/i)) {
            td.style.textAlign = 'right';
          }
        }
        tr.appendChild(td);
      });
      // Row click  detail panel + WebSocket event
      tr.onclick = function() {
        var rowObj = {};
        columns.forEach(function(col, i) { rowObj[col] = row[i]; });
        showRowDetail(columns, row, dtypes, cardData);
        // Fire WebSocket event
        if (cardData && state.ws && state.connected) {
          state.ws.send(JSON.stringify({
            type: 'display.event',
            event_type: 'row_click',
            card_id: cardData.card_id,
            payload: { row_index: rowIdx, row: rowObj },
          }));
        }
      };
      tbody.appendChild(tr);
    });
  }

  function showRowDetail(columns, row, dtypes, cardData) {
    // Remove any existing detail panel
    closeRowDetail();

    var overlay = document.createElement('div');
    overlay.className = 'row-detail-overlay';
    overlay.id = 'row-detail-overlay';
    overlay.onclick = function(e) {
      if (e.target === overlay) closeRowDetail();
    };

    var panel = document.createElement('div');
    panel.className = 'row-detail-panel';

    var header = document.createElement('div');
    header.className = 'row-detail-header';
    var headerTitle = document.createElement('span');
    headerTitle.textContent = (cardData && cardData.title ? cardData.title + ' \u2014 ' : '') + 'Row Detail';
    header.appendChild(headerTitle);
    var closeBtn = document.createElement('button');
    closeBtn.className = 'row-detail-close';
    closeBtn.innerHTML = '&times;';
    closeBtn.onclick = closeRowDetail;
    header.appendChild(closeBtn);
    panel.appendChild(header);

    var body = document.createElement('div');
    body.className = 'row-detail-body';

    var dl = document.createElement('div');
    dl.className = 'kv-list';

    columns.forEach(function(col, i) {
      var keyEl = document.createElement('div');
      keyEl.className = 'kv-key';
      var keyText = col;
      if (dtypes && dtypes[col]) {
        keyText += ' ';
        var badge = document.createElement('span');
        badge.className = 'type-badge';
        badge.textContent = mapDtypeLabel(dtypes[col]);
        keyEl.textContent = col + ' ';
        keyEl.appendChild(badge);
      } else {
        keyEl.textContent = col;
      }

      var valEl = document.createElement('div');
      valEl.className = 'kv-value';
      valEl.textContent = row[i] === null ? '\u2014' : String(row[i]);
      valEl.style.wordBreak = 'break-all';

      dl.appendChild(keyEl);
      dl.appendChild(valEl);
    });

    body.appendChild(dl);
    panel.appendChild(body);
    overlay.appendChild(panel);
    document.body.appendChild(overlay);

    // ESC to close
    document.addEventListener('keydown', _rowDetailEsc);
  }

  function _rowDetailEsc(e) {
    if (e.key === 'Escape') closeRowDetail();
  }

  function closeRowDetail() {
    var overlay = document.getElementById('row-detail-overlay');
    if (overlay) overlay.remove();
    document.removeEventListener('keydown', _rowDetailEsc);
  }

  function createPager(artifactId, totalRowsRef, columns, dtypes, wrapper, rowInfoEl, pagerState, sortState, searchState, cardData, updateRowInfo) {
    var limit = pagerState.limit;

    var pager = document.createElement('div');
    pager.className = 'table-pager';

    var prevBtn = document.createElement('button');
    prevBtn.textContent = '\u2190 Prev';
    prevBtn.disabled = true;

    var pageInfo = document.createElement('span');

    var nextBtn = document.createElement('button');
    nextBtn.textContent = 'Next \u2192';

    function updatePage() {
      var total = totalRowsRef.value;
      var start = total > 0 ? pagerState.offset + 1 : 0;
      var end = Math.min(pagerState.offset + limit, total);
      pageInfo.textContent = start + '\u2013' + end + ' of ' + total.toLocaleString();
      prevBtn.disabled = pagerState.offset === 0;
      nextBtn.disabled = pagerState.offset + limit >= total;
      if (updateRowInfo) updateRowInfo();
    }

    function loadPage() {
      var url = '/api/table/' + artifactId + '?offset=' + pagerState.offset + '&limit=' + limit;
      if (sortState && sortState.col) {
        url += '&sort=' + encodeURIComponent(sortState.col) + '&asc=' + sortState.asc;
      }
      if (searchState && searchState.text) {
        url += '&search=' + encodeURIComponent(searchState.text);
      }
      fetch(url)
        .then(function(r) { return r.json(); })
        .then(function(data) {
          totalRowsRef.value = data.total_rows;
          var tbody = wrapper.querySelector('tbody');
          renderTableRows(tbody, data.rows, columns, dtypes, cardData);
          updatePage();
        });
    }

    prevBtn.onclick = function() {
      pagerState.offset = Math.max(0, pagerState.offset - limit);
      loadPage();
    };

    nextBtn.onclick = function() {
      pagerState.offset = pagerState.offset + limit;
      loadPage();
    };

    pager.appendChild(prevBtn);
    pager.appendChild(pageInfo);
    pager.appendChild(nextBtn);
    updatePage();

    return pager;
  }

  function renderMarkdown(container, cardData) {
    var text = (cardData.preview && cardData.preview.text) || '';
    container.className += ' markdown-body';

    if (window.marked) {
      container.innerHTML = window.marked.parse(text);
    } else {
      container.innerHTML = basicMarkdown(text);
      loadMarked(function() {
        container.innerHTML = window.marked.parse(text);
      });
    }
  }

  function basicMarkdown(text) {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/^### (.+)$/gm, '<h3>$1</h3>')
      .replace(/^## (.+)$/gm, '<h2>$1</h2>')
      .replace(/^# (.+)$/gm, '<h1>$1</h1>')
      .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.+?)\*/g, '<em>$1</em>')
      .replace(/`([^`]+)`/g, '<code>$1</code>')
      .replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
      .replace(/\n\n/g, '</p><p>')
      .replace(/\n/g, '<br>')
      .replace(/^/, '<p>')
      .replace(/$/, '</p>');
  }

  function loadMarked(callback) {
    if (state.markedLoaded) return;
    state.markedLoaded = true;

    var script = document.createElement('script');
    script.src = '/static/vendor/marked.min.js';
    script.onload = function() {
      if (window.marked) {
        window.marked.setOptions({ breaks: true, gfm: true });
        if (callback) callback();
      }
    };
    script.onerror = function() {
      state.markedLoaded = false;
    };
    document.head.appendChild(script);
  }

  function renderKeyValue(container, cardData) {
    var items = (cardData.preview && cardData.preview.items) || {};
    var dl = document.createElement('div');
    dl.className = 'kv-list';

    Object.keys(items).forEach(function(key) {
      var keyEl = document.createElement('div');
      keyEl.className = 'kv-key';
      keyEl.textContent = key;

      var valEl = document.createElement('div');
      valEl.className = 'kv-value';
      valEl.textContent = items[key];

      dl.appendChild(keyEl);
      dl.appendChild(valEl);
    });

    container.appendChild(dl);
  }

  // --- Plotly Charts ---

  function renderPlotly(container, cardData) {
    var spec = cardData.preview && cardData.preview.spec;
    if (!spec) {
      container.textContent = 'No chart data';
      return;
    }

    var plotDiv = document.createElement('div');
    plotDiv.className = 'plotly-container';
    plotDiv.id = 'plotly-' + cardData.card_id;
    container.appendChild(plotDiv);

    function doRender() {
      var data = spec.data || [];
      var layout = Object.assign({}, spec.layout || {}, {
        autosize: true,
        margin: { l: 50, r: 30, t: 40, b: 50 },
        paper_bgcolor: 'transparent',
        plot_bgcolor: 'transparent',
        font: { color: getComputedStyle(document.documentElement).getPropertyValue('--text').trim() },
      });
      var config = { responsive: true, displayModeBar: true, displaylogo: false };

      window.Plotly.newPlot(plotDiv, data, layout, config).then(function() {
        // Attach point selection event
        plotDiv.on('plotly_selected', function(eventData) {
          if (eventData && state.ws && state.connected) {
            var points = (eventData.points || []).map(function(pt) {
              return { x: pt.x, y: pt.y, pointIndex: pt.pointIndex, curveNumber: pt.curveNumber };
            });
            state.ws.send(JSON.stringify({
              type: 'display.event',
              event_type: 'point_select',
              card_id: cardData.card_id,
              payload: { points: points },
            }));
          }
        });

        plotDiv.on('plotly_click', function(eventData) {
          if (eventData && state.ws && state.connected) {
            var points = (eventData.points || []).map(function(pt) {
              return { x: pt.x, y: pt.y, pointIndex: pt.pointIndex, curveNumber: pt.curveNumber };
            });
            state.ws.send(JSON.stringify({
              type: 'display.event',
              event_type: 'point_click',
              card_id: cardData.card_id,
              payload: { points: points },
            }));
          }
        });
      });
    }

    if (window.Plotly) {
      doRender();
    } else {
      // Show loading indicator
      var loading = document.createElement('div');
      loading.className = 'chart-loading';
      loading.textContent = 'Loading chart library...';
      plotDiv.appendChild(loading);

      loadPlotly(function() {
        plotDiv.removeChild(loading);
        doRender();
      });
    }
  }

  function loadPlotly(callback) {
    if (window.Plotly) {
      if (callback) callback();
      return;
    }

    // Queue callbacks if already loading
    if (state.plotlyLoaded) {
      state.plotlyCallbacks.push(callback);
      return;
    }
    state.plotlyLoaded = true;
    state.plotlyCallbacks.push(callback);

    var script = document.createElement('script');
    script.src = '/static/vendor/plotly.min.js';
    script.onload = function() {
      var cbs = state.plotlyCallbacks;
      state.plotlyCallbacks = [];
      cbs.forEach(function(cb) { if (cb) cb(); });
    };
    script.onerror = function() {
      state.plotlyLoaded = false;
      var cbs = state.plotlyCallbacks;
      state.plotlyCallbacks = [];
      cbs.forEach(function(cb) {
        // Attempt fallback: render as static image if artifact exists
      });
    };
    document.head.appendChild(script);
  }

  // Resize Plotly charts on window resize
  window.addEventListener('resize', function() {
    if (!window.Plotly) return;
    var plots = document.querySelectorAll('.plotly-container .js-plotly-plot');
    plots.forEach(function(plot) {
      window.Plotly.Plots.resize(plot);
    });
  });

  // Re-color Plotly charts on theme change
  var _origThemeToggle = themeToggleEl.onclick;
  themeToggleEl.onclick = function() {
    _origThemeToggle.call(this);
    if (!window.Plotly) return;
    var textColor = getComputedStyle(document.documentElement).getPropertyValue('--text').trim();
    var plots = document.querySelectorAll('.plotly-container .js-plotly-plot');
    plots.forEach(function(plot) {
      window.Plotly.relayout(plot, {
        'paper_bgcolor': 'transparent',
        'plot_bgcolor': 'transparent',
        'font.color': textColor,
      });
    });
  };

  // --- Image Cards (matplotlib SVG) ---

  function renderImage(container, cardData) {
    var preview = cardData.preview || {};
    var imgContainer = document.createElement('div');
    imgContainer.className = 'image-container';

    var img = document.createElement('img');

    if (preview.data && preview.format === 'svg') {
      img.src = 'data:image/svg+xml;base64,' + preview.data;
    } else if (preview.data && preview.format === 'png') {
      img.src = 'data:image/png;base64,' + preview.data;
    } else if (cardData.artifact_id) {
      // Fall back to artifact endpoint
      img.src = '/api/artifact/' + cardData.artifact_id;
    } else {
      container.textContent = 'No image data';
      return;
    }

    img.alt = cardData.title || 'Figure';
    img.style.maxWidth = '100%';
    imgContainer.appendChild(img);
    container.appendChild(imgContainer);
  }

  // --- Response UI for waiting cards ---

  function buildResponseUI(cardData, cardEl) {
    var container = document.createElement('div');
    container.className = 'card-response-ui';

    // Prompt
    if (cardData.prompt) {
      var promptEl = document.createElement('div');
      promptEl.className = 'response-prompt';
      promptEl.textContent = cardData.prompt;
      container.appendChild(promptEl);
    }

    // Message input
    var msgInput = document.createElement('textarea');
    msgInput.className = 'response-message-input';
    msgInput.placeholder = 'Optional message...';
    msgInput.rows = 1;
    container.appendChild(msgInput);

    // Actions
    var actionsRow = document.createElement('div');
    actionsRow.className = 'response-actions';

    var confirmBtn = document.createElement('button');
    confirmBtn.className = 'response-btn response-btn-confirm';
    confirmBtn.textContent = 'Confirm';
    confirmBtn.onclick = function() {
      sendResponse(cardData, cardEl, 'confirm', msgInput.value);
    };
    actionsRow.appendChild(confirmBtn);

    var skipBtn = document.createElement('button');
    skipBtn.className = 'response-btn response-btn-skip';
    skipBtn.textContent = 'Skip';
    skipBtn.onclick = function() {
      sendResponse(cardData, cardEl, 'skip', null);
    };
    actionsRow.appendChild(skipBtn);

    // Timeout countdown
    var timeoutEl = document.createElement('span');
    timeoutEl.className = 'response-timeout';
    actionsRow.appendChild(timeoutEl);
    container.appendChild(actionsRow);

    // Start countdown (use backend-configured timeout, default 5 min)
    var remaining = (cardData.timeout && cardData.timeout > 0) ? Math.floor(cardData.timeout) : 300;
    function updateCountdown() {
      var mins = Math.floor(remaining / 60);
      var secs = remaining % 60;
      timeoutEl.textContent = mins + ':' + (secs < 10 ? '0' : '') + secs;
      if (remaining <= 0) {
        clearInterval(timer);
        timeoutEl.textContent = 'Timed out';
        return;
      }
      remaining--;
    }
    updateCountdown();
    var timer = setInterval(updateCountdown, 1000);
    container._timer = timer;

    return container;
  }

  function sendResponse(cardData, cardEl, action, message) {
    // Gather selected rows if this is a table card with selection checkboxes
    var selectedRows = null;
    var columns = null;
    var tbody = cardEl.querySelector('tbody');
    if (cardData.card_type === 'table' && tbody) {
      var checkboxes = tbody.querySelectorAll('input[type="checkbox"]:checked');
      if (checkboxes.length > 0) {
        columns = cardData.preview.columns;
        selectedRows = [];
        checkboxes.forEach(function(cb) {
          var tr = cb.closest('tr');
          var cells = [];
          tr.querySelectorAll('td:not(.select-col)').forEach(function(td) {
            cells.push(td.textContent === '\u2014' ? null : td.textContent);
          });
          selectedRows.push(cells);
        });
      }
    }

    // Send via WebSocket
    if (state.ws && state.connected) {
      state.ws.send(JSON.stringify({
        type: 'display.event',
        event_type: 'response',
        card_id: cardData.card_id,
        payload: {
          action: action,
          message: message,
          selected_rows: selectedRows,
          columns: columns,
        },
      }));
    }

    // Update UI: remove response panel, remove waiting style
    var responseUI = cardEl.querySelector('.card-response-ui');
    if (responseUI) {
      if (responseUI._timer) clearInterval(responseUI._timer);
      responseUI.remove();
    }
    cardEl.classList.remove('waiting');

    // Show confirmation badge
    var badge = document.createElement('span');
    badge.className = 'sent-badge';
    badge.textContent = action === 'confirm' ? 'Confirmed' : 'Skipped';
    var header = cardEl.querySelector('.card-header');
    if (header) header.appendChild(badge);
  }

  // --- Send to Agent popover ---

  function togglePromptPopover(btn, cardData, cardEl) {
    // Close any existing popover
    var existing = document.querySelector('.prompt-popover');
    if (existing) {
      existing.remove();
      return;
    }

    var popover = document.createElement('div');
    popover.className = 'prompt-popover';

    var textarea = document.createElement('textarea');
    textarea.placeholder = 'Message for the agent...';
    popover.appendChild(textarea);

    var sendBtnEl = document.createElement('button');
    sendBtnEl.className = 'send-btn';
    sendBtnEl.textContent = 'Send';
    sendBtnEl.onclick = function() {
      var promptText = textarea.value.trim();
      if (!promptText) return;
      submitSendToAgent(cardData, cardEl, promptText);
      popover.remove();
    };
    popover.appendChild(sendBtnEl);

    // Position relative to the button's parent header
    var header = btn.closest('.card-header');
    if (header) header.style.position = 'relative';
    header.appendChild(popover);

    textarea.focus();

    // Close on click outside
    function closeOnOutside(e) {
      if (!popover.contains(e.target) && e.target !== btn) {
        popover.remove();
        document.removeEventListener('mousedown', closeOnOutside);
      }
    }
    setTimeout(function() {
      document.addEventListener('mousedown', closeOnOutside);
    }, 0);
  }

  function submitSendToAgent(cardData, cardEl, promptText) {
    // Gather selected/visible rows for table cards
    var selectedRows = null;
    var columns = null;
    var tbody = cardEl.querySelector('tbody');
    if (cardData.card_type === 'table' && tbody) {
      columns = cardData.preview.columns;
      // Try checked rows first, fall back to all visible rows
      var checkboxes = tbody.querySelectorAll('input[type="checkbox"]:checked');
      if (checkboxes.length > 0) {
        selectedRows = [];
        checkboxes.forEach(function(cb) {
          var tr = cb.closest('tr');
          var cells = [];
          tr.querySelectorAll('td:not(.select-col)').forEach(function(td) {
            cells.push(td.textContent === '\u2014' ? null : td.textContent);
          });
          selectedRows.push(cells);
        });
      }
    }

    // Send via WebSocket
    if (state.ws && state.connected) {
      state.ws.send(JSON.stringify({
        type: 'display.event',
        event_type: 'send_to_agent',
        card_id: cardData.card_id,
        payload: {
          prompt: promptText,
          selected_rows: selectedRows,
          columns: columns,
          instruction: cardData.on_send || null,
        },
      }));
    }

    // Submit via REST only if WebSocket is not connected (fallback)
    if (!state.ws || !state.connected) {
      fetch('/api/requests', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          card_id: cardData.card_id,
          prompt: promptText,
          selected_rows: selectedRows,
          columns: columns,
          instruction: cardData.on_send || null,
        }),
      }).catch(function() {});
    }

    // Show "Sent" confirmation and update badge
    incrementRequestBadge();
    showToast('Sent to agent');

    // Copy formatted snippet to clipboard
    var snippet = 'Agent Request: ' + promptText;
    if (cardData.title) snippet = '[' + cardData.title + '] ' + snippet;
    navigator.clipboard.writeText(snippet).catch(function() {});
  }

  function addSection(title, runId) {
    var empty = document.getElementById('empty-state');
    if (empty && empty.parentNode) {
      empty.remove();
    }

    if (runId) trackRunId(runId);

    var div = document.createElement('div');
    div.className = 'section-divider';
    div.textContent = title;
    div.dataset.runId = runId || '';
    feed.appendChild(div);

    if (state.activeRunFilter) {
      applyRunFilter();
    }

    scrollToBottom();
  }

  function updateCard(cardId, newCardData) {
    var el = document.getElementById('card-' + cardId);
    if (!el) return;

    // Update state.cards entry
    if (newCardData) {
      for (var i = 0; i < state.cards.length; i++) {
        if (state.cards[i].card_id === cardId) {
          state.cards[i] = newCardData;
          break;
        }
      }

      // Update title
      var titleEl = el.querySelector('.card-title');
      if (titleEl && newCardData.title) {
        titleEl.textContent = newCardData.title;
      }

      // Re-render body content
      var body = el.querySelector('.card-body');
      if (body) {
        body.innerHTML = '';
        switch (newCardData.card_type) {
          case 'table':
            renderTable(body, newCardData);
            break;
          case 'plotly':
            renderPlotly(body, newCardData);
            break;
          case 'image':
            renderImage(body, newCardData);
            break;
          case 'markdown':
            renderMarkdown(body, newCardData);
            break;
          case 'keyvalue':
            renderKeyValue(body, newCardData);
            break;
          default:
            body.textContent = JSON.stringify(newCardData.preview);
        }
      }
    }

    // Flash animation to highlight the update
    el.classList.remove('flash');
    void el.offsetWidth; // Force reflow
    el.classList.add('flash');
    setTimeout(function() { el.classList.remove('flash'); }, 600);
  }

  function rebuildRunFilter() {
    // Rebuild runIds from cards (used as fallback)
    var runs = [];
    state.cards.forEach(function(c) {
      if (c.run_id && runs.indexOf(c.run_id) === -1) runs.push(c.run_id);
    });
    state.runIds = runs;

    // If the current filter no longer exists, switch to "All runs"
    if (state.activeRunFilter && runs.indexOf(state.activeRunFilter) === -1) {
      state.activeRunFilter = '';
      updateDropdownTrigger();
    }
  }

  function showEmptyState() {
    var existing = document.getElementById('empty-state');
    if (existing) return;

    var empty = document.createElement('div');
    empty.className = 'empty-state';
    empty.id = 'empty-state';
    empty.innerHTML = '<div style="font-size: 32px; opacity: 0.3;">&#9671;</div>'
      + '<div style="font-size: 15px; font-weight: 500;">No analyses yet</div>'
      + '<div style="font-size: 13px;">Run an agent to get started</div>'
      + '<div><code>from m4.display import show</code></div>';
    feed.appendChild(empty);
  }

  // --- UI Helpers ---
  function updateStatus(status) {
    var dotClass = status === 'connected' ? 'status-connected'
      : status === 'disconnected' ? 'status-disconnected'
      : 'status-connecting';
    var label = status.charAt(0).toUpperCase() + status.slice(1);
    statusEl.innerHTML = '<span class="status-dot ' + dotClass + '"></span> ' + label;
  }

  function updateCardCount() {
    var all = feed.querySelectorAll('.card');
    var visible = 0;
    all.forEach(function(el) {
      if (!el.classList.contains('hidden-by-filter')) visible++;
    });
    var text = visible + ' card' + (visible !== 1 ? 's' : '');
    if (visible !== all.length) {
      text += ' (of ' + all.length + ')';
    }
    cardCountEl.textContent = text;

    // Footer: show run label or run count
    if (state.activeRunFilter) {
      var run = null;
      for (var i = 0; i < state.runs.length; i++) {
        if (state.runs[i].label === state.activeRunFilter) { run = state.runs[i]; break; }
      }
      if (run && run.start_time) {
        sessionInfoEl.textContent = state.activeRunFilter + ' \u00b7 ' + dateGroupLabel(run.start_time);
      } else {
        sessionInfoEl.textContent = state.activeRunFilter;
      }
    } else {
      var totalRuns = state.runs.length;
      sessionInfoEl.textContent = totalRuns > 0 ? totalRuns + ' run' + (totalRuns !== 1 ? 's' : '') : '';
    }
  }

  function loadSessionInfo() {
    fetch('/api/session')
      .then(function(r) { return r.json(); })
      .then(function(data) {
        var sid = (data.session_id || '').substring(0, 8);
        sessionInfoEl.textContent = sid ? 'session: ' + sid : '';
      })
      .catch(function() {});
  }

  function loadRuns() {
    fetch('/api/runs')
      .then(function(r) { return r.json(); })
      .then(function(runs) {
        if (!Array.isArray(runs)) return;
        state.runs = runs;
        state.runIds = [];
        runs.forEach(function(run) {
          var label = run.label || run.dir_name || '';
          if (label && state.runIds.indexOf(label) === -1) state.runIds.push(label);
        });

        // Validate current filter still exists
        if (state.activeRunFilter && state.runIds.indexOf(state.activeRunFilter) === -1) {
          state.activeRunFilter = '';
          updateDropdownTrigger();
        }

        // Auto-select most recent run on first load
        if (!state.liveMode && !state.activeRunFilter && runs.length > 0) {
          state.activeRunFilter = runs[0].label;
          updateDropdownTrigger();
          applyRunFilter();
          updateRunMetadataBar();
        }

        updateCardCount();

        // Update empty state
        if (runs.length === 0 && state.cards.length === 0) {
          showEmptyState();
        }
      })
      .catch(function() {});
  }

  function scrollToBottom() {
    requestAnimationFrame(function() {
      window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
    });
  }

  // --- Pending Request Badge ---
  var requestBadgeEl = document.getElementById('request-badge');

  function pollRequestCount() {
    fetch('/api/requests', {
      headers: { 'Content-Type': 'application/json' },
    })
      .then(function(r) {
        // 401 means auth required (no token from browser), which is expected.
        // The badge shows based on the count of queued requests the server knows about.
        // Use the public POST count instead  track locally.
        return null;
      })
      .catch(function() {});
  }

  // Track pending request count client-side (incremented on send, no server poll needed)
  var pendingRequestCount = 0;

  function incrementRequestBadge() {
    pendingRequestCount++;
    requestBadgeEl.textContent = pendingRequestCount;
    requestBadgeEl.classList.remove('hidden');
  }

  function decrementRequestBadge() {
    pendingRequestCount = Math.max(0, pendingRequestCount - 1);
    if (pendingRequestCount === 0) {
      requestBadgeEl.classList.add('hidden');
    } else {
      requestBadgeEl.textContent = pendingRequestCount;
    }
  }

  // --- Init ---
  connect();
})();
</script>
</body>
</html>

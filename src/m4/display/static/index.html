<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>M4 Display</title>
<style>
  :root {
    --bg: #ffffff;
    --bg-card: #f8f9fa;
    --bg-header: #f0f1f3;
    --text: #1a1a2e;
    --text-muted: #6c757d;
    --border: #dee2e6;
    --accent: #4361ee;
    --accent-hover: #3a56d4;
    --success: #2ec4b6;
    --error: #e63946;
    --warning: #ffc107;
    --font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
    --mono: 'SF Mono', 'Fira Code', 'Fira Mono', Menlo, Consolas, monospace;
    --radius: 8px;
    --shadow: 0 1px 3px rgba(0,0,0,0.08);
    --pin-color: #f59e0b;
  }

  [data-theme="dark"] {
    --bg: #1a1b26;
    --bg-card: #24253a;
    --bg-header: #1e1f32;
    --text: #c0caf5;
    --text-muted: #7982a9;
    --border: #33354a;
    --accent: #7aa2f7;
    --accent-hover: #89b4fa;
    --success: #9ece6a;
    --error: #f7768e;
    --warning: #e0af68;
    --shadow: 0 1px 3px rgba(0,0,0,0.3);
    --pin-color: #e0af68;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: var(--font);
    background: var(--bg);
    color: var(--text);
    line-height: 1.5;
    transition: background 0.2s, color 0.2s;
  }

  /* Header */
  .header {
    position: sticky;
    top: 0;
    z-index: 100;
    background: var(--bg);
    border-bottom: 1px solid var(--border);
    padding: 10px 24px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    transition: background 0.2s, border-color 0.2s;
  }

  .header-left {
    display: flex;
    align-items: center;
    gap: 16px;
  }

  .header h1 {
    font-size: 15px;
    font-weight: 600;
    letter-spacing: -0.3px;
  }

  .run-filter {
    padding: 5px 10px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--bg);
    color: var(--text);
    font-size: 12px;
    font-family: var(--font);
    cursor: pointer;
    outline: none;
    transition: border-color 0.15s;
  }

  .run-filter:focus { border-color: var(--accent); }

  .header-actions {
    display: flex;
    gap: 6px;
    align-items: center;
  }

  .btn {
    padding: 5px 12px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--bg);
    color: var(--text);
    font-size: 12px;
    cursor: pointer;
    font-family: var(--font);
    transition: background 0.15s, border-color 0.15s, color 0.15s;
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }

  .btn:hover { background: var(--bg-header); }

  .btn-danger {
    color: var(--error);
    border-color: var(--error);
  }

  .btn-danger:hover {
    background: var(--error);
    color: white;
  }

  .btn-icon {
    padding: 5px 8px;
    border: none;
    background: transparent;
    color: var(--text-muted);
    cursor: pointer;
    border-radius: 4px;
    font-size: 14px;
    line-height: 1;
    transition: color 0.15s, background 0.15s;
  }

  .btn-icon:hover {
    color: var(--text);
    background: var(--bg-header);
  }

  /* Card feed */
  .feed {
    max-width: 960px;
    margin: 0 auto;
    padding: 24px;
    display: flex;
    flex-direction: column;
    gap: 16px;
    min-height: calc(100vh - 110px);
  }

  .empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    flex: 1;
    color: var(--text-muted);
    gap: 8px;
    padding: 80px 0;
  }

  .empty-state code {
    font-family: var(--mono);
    background: var(--bg-card);
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 13px;
  }

  /* Cards */
  .card {
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--bg);
    box-shadow: var(--shadow);
    overflow: hidden;
    animation: fadeIn 0.2s ease;
    transition: border-color 0.15s, box-shadow 0.15s, background 0.2s;
  }

  .card.pinned {
    border-color: var(--pin-color);
    box-shadow: 0 0 0 1px var(--pin-color), var(--shadow);
  }

  .card.hidden-by-filter { display: none; }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(8px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .card-header {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    background: var(--bg-header);
    border-bottom: 1px solid var(--border);
    font-size: 13px;
    gap: 8px;
    user-select: none;
    transition: background 0.2s, border-color 0.2s;
  }

  .card-collapse-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-muted);
    font-size: 10px;
    padding: 2px;
    line-height: 1;
    transition: transform 0.15s, color 0.15s;
    flex-shrink: 0;
  }

  .card-collapse-btn:hover { color: var(--text); }
  .card-collapse-btn.collapsed { transform: rotate(-90deg); }

  .card-title {
    font-weight: 600;
    font-size: 13px;
    flex: 1;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .card-actions {
    display: flex;
    gap: 2px;
    align-items: center;
    flex-shrink: 0;
  }

  .card-action-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-muted);
    font-size: 13px;
    padding: 3px 5px;
    border-radius: 3px;
    line-height: 1;
    transition: color 0.15s, background 0.15s;
  }

  .card-action-btn:hover {
    color: var(--text);
    background: var(--bg-card);
  }

  .card-action-btn.pinned { color: var(--pin-color); }
  .card-action-btn.copied { color: var(--success); }

  .card-meta {
    color: var(--text-muted);
    font-size: 11px;
    white-space: nowrap;
    flex-shrink: 0;
  }

  .card-body {
    padding: 16px;
    transition: background 0.2s;
  }

  .card-body.collapsed {
    display: none;
  }

  .card-provenance {
    padding: 6px 12px;
    border-top: 1px solid var(--border);
    font-size: 11px;
    color: var(--text-muted);
    font-family: var(--mono);
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    transition: border-color 0.2s;
  }

  .card-provenance.collapsed {
    display: none;
  }

  /* Table cards */
  .table-wrapper {
    overflow-x: auto;
    font-size: 13px;
  }

  .table-wrapper table {
    width: 100%;
    border-collapse: collapse;
    font-family: var(--mono);
    font-size: 12px;
  }

  .table-wrapper th {
    text-align: left;
    padding: 7px 12px;
    border-bottom: 2px solid var(--border);
    font-weight: 600;
    white-space: nowrap;
    background: var(--bg-card);
    position: sticky;
    top: 0;
    cursor: pointer;
    user-select: none;
    transition: background 0.15s;
  }

  .table-wrapper th:hover {
    background: var(--bg-header);
  }

  .table-wrapper th .sort-indicator {
    display: inline-block;
    margin-left: 4px;
    font-size: 10px;
    color: var(--text-muted);
    opacity: 0;
    transition: opacity 0.15s;
  }

  .table-wrapper th:hover .sort-indicator { opacity: 0.5; }
  .table-wrapper th .sort-indicator.active { opacity: 1; color: var(--accent); }

  .table-wrapper td {
    padding: 5px 12px;
    border-bottom: 1px solid var(--border);
    white-space: nowrap;
    max-width: 300px;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .table-wrapper tr:hover td {
    background: var(--bg-card);
  }

  .table-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    font-size: 12px;
    color: var(--text-muted);
  }

  .table-pager {
    display: flex;
    gap: 4px;
    align-items: center;
  }

  .table-pager button {
    padding: 3px 10px;
    border: 1px solid var(--border);
    border-radius: 4px;
    background: var(--bg);
    color: var(--text);
    cursor: pointer;
    font-size: 12px;
    font-family: var(--font);
    transition: background 0.15s;
  }

  .table-pager button:hover { background: var(--bg-header); }
  .table-pager button:disabled { opacity: 0.4; cursor: default; }

  /* Markdown cards */
  .markdown-body {
    font-size: 14px;
    line-height: 1.7;
  }

  .markdown-body h1, .markdown-body h2, .markdown-body h3 {
    margin: 16px 0 8px;
    font-weight: 600;
  }

  .markdown-body h1 { font-size: 20px; }
  .markdown-body h2 { font-size: 17px; }
  .markdown-body h3 { font-size: 15px; }
  .markdown-body p { margin: 8px 0; }
  .markdown-body strong { font-weight: 600; }

  .markdown-body code {
    font-family: var(--mono);
    background: var(--bg-card);
    padding: 1px 5px;
    border-radius: 3px;
    font-size: 13px;
  }

  .markdown-body pre {
    background: var(--bg-card);
    padding: 12px 16px;
    border-radius: 6px;
    overflow-x: auto;
    margin: 8px 0;
  }

  .markdown-body pre code {
    background: none;
    padding: 0;
  }

  .markdown-body ul, .markdown-body ol {
    padding-left: 24px;
    margin: 8px 0;
  }

  /* Key-value cards */
  .kv-list {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 4px 16px;
    font-size: 13px;
  }

  .kv-key {
    font-weight: 600;
    color: var(--text-muted);
    text-align: right;
    font-family: var(--mono);
  }

  .kv-value {
    font-family: var(--mono);
  }

  /* Section dividers */
  .section-divider {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 8px 0;
    color: var(--text-muted);
    font-size: 13px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .section-divider.hidden-by-filter { display: none; }

  .section-divider::before,
  .section-divider::after {
    content: '';
    flex: 1;
    height: 1px;
    background: var(--border);
  }

  /* Footer */
  .footer {
    position: sticky;
    bottom: 0;
    background: var(--bg);
    border-top: 1px solid var(--border);
    padding: 6px 24px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 11px;
    color: var(--text-muted);
    transition: background 0.2s, border-color 0.2s;
  }

  .status-dot {
    display: inline-block;
    width: 7px;
    height: 7px;
    border-radius: 50%;
    margin-right: 5px;
  }

  .status-connected { background: var(--success); }
  .status-disconnected { background: var(--error); }
  .status-connecting { background: var(--warning); }

  /* Plotly chart cards */
  .plotly-container {
    width: 100%;
    min-height: 300px;
    position: relative;
  }

  .plotly-container .js-plotly-plot {
    width: 100% !important;
  }

  .chart-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 200px;
    color: var(--text-muted);
    font-size: 13px;
    gap: 8px;
  }

  .chart-loading::before {
    content: '';
    width: 16px;
    height: 16px;
    border: 2px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Image cards (matplotlib SVG) */
  .image-container {
    text-align: center;
  }

  .image-container img {
    max-width: 100%;
    height: auto;
    border-radius: 4px;
  }

  /* Copy toast */
  .copy-toast {
    position: fixed;
    bottom: 48px;
    left: 50%;
    transform: translateX(-50%) translateY(8px);
    background: var(--text);
    color: var(--bg);
    padding: 6px 16px;
    border-radius: 6px;
    font-size: 12px;
    opacity: 0;
    transition: opacity 0.2s, transform 0.2s;
    pointer-events: none;
    z-index: 200;
  }

  .copy-toast.visible {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
</style>
</head>
<body>

<div class="header">
  <div class="header-left">
    <h1>M4 Display</h1>
    <select class="run-filter" id="run-filter" title="Filter by run">
      <option value="">All runs</option>
    </select>
  </div>
  <div class="header-actions">
    <button class="btn-icon" id="theme-toggle" title="Toggle theme">&#9789;</button>
    <button class="btn btn-danger" onclick="clearCards()">Clear</button>
  </div>
</div>

<div class="feed" id="feed">
  <div class="empty-state" id="empty-state">
    <div style="font-size: 32px; opacity: 0.3;">&#9671;</div>
    <div>Waiting for data...</div>
    <div><code>from m4.display import show</code></div>
  </div>
</div>

<div class="footer">
  <div id="status">
    <span class="status-dot status-connecting"></span>
    Connecting...
  </div>
  <div id="session-info"></div>
  <div id="card-count">0 cards</div>
</div>

<div class="copy-toast" id="copy-toast">Copied to clipboard</div>

<script>
(function() {
  'use strict';

  // --- State ---
  var state = {
    ws: null,
    cards: [],
    connected: false,
    reconnectDelay: 1000,
    reconnectTimer: null,
    markedLoaded: false,
    plotlyLoaded: false,
    plotlyCallbacks: [],
    runIds: [],
    activeRunFilter: '',
  };

  // --- Elements ---
  var feed = document.getElementById('feed');
  var emptyState = document.getElementById('empty-state');
  var statusEl = document.getElementById('status');
  var sessionInfoEl = document.getElementById('session-info');
  var cardCountEl = document.getElementById('card-count');
  var runFilterEl = document.getElementById('run-filter');
  var themeToggleEl = document.getElementById('theme-toggle');
  var copyToastEl = document.getElementById('copy-toast');

  // --- Theme ---
  function initTheme() {
    var saved = localStorage.getItem('m4-display-theme');
    if (saved === 'dark') {
      document.documentElement.setAttribute('data-theme', 'dark');
      themeToggleEl.innerHTML = '&#9788;';
    }
  }

  themeToggleEl.onclick = function() {
    var isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    if (isDark) {
      document.documentElement.removeAttribute('data-theme');
      localStorage.setItem('m4-display-theme', 'light');
      themeToggleEl.innerHTML = '&#9789;';
    } else {
      document.documentElement.setAttribute('data-theme', 'dark');
      localStorage.setItem('m4-display-theme', 'dark');
      themeToggleEl.innerHTML = '&#9788;';
    }
  };

  initTheme();

  // --- Run Filter ---
  runFilterEl.onchange = function() {
    state.activeRunFilter = runFilterEl.value;
    applyRunFilter();
  };

  function trackRunId(runId) {
    if (!runId || state.runIds.indexOf(runId) !== -1) return;
    state.runIds.push(runId);
    var opt = document.createElement('option');
    opt.value = runId;
    opt.textContent = runId;
    runFilterEl.appendChild(opt);
  }

  function applyRunFilter() {
    var filter = state.activeRunFilter;
    var items = feed.querySelectorAll('.card, .section-divider');
    items.forEach(function(el) {
      if (!filter) {
        el.classList.remove('hidden-by-filter');
      } else {
        var elRun = el.dataset.runId || '';
        if (elRun === filter || !elRun) {
          el.classList.remove('hidden-by-filter');
        } else {
          el.classList.add('hidden-by-filter');
        }
      }
    });
    updateCardCount();
  }

  // --- WebSocket ---
  function connect() {
    if (state.reconnectTimer) {
      clearTimeout(state.reconnectTimer);
      state.reconnectTimer = null;
    }
    updateStatus('connecting');

    var protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
    var ws;
    try {
      ws = new WebSocket(protocol + '//' + location.host + '/ws');
    } catch (e) {
      scheduleReconnect();
      return;
    }

    ws.onopen = function() {
      state.ws = ws;
      state.connected = true;
      state.reconnectDelay = 1000;
      updateStatus('connected');
      loadSessionInfo();
    };

    ws.onmessage = function(event) {
      try {
        var msg = JSON.parse(event.data);
        handleMessage(msg);
      } catch (e) {
        console.error('Failed to parse message:', e);
      }
    };

    ws.onclose = function() {
      state.connected = false;
      state.ws = null;
      updateStatus('disconnected');
      scheduleReconnect();
    };

    ws.onerror = function() {
      ws.close();
    };
  }

  function scheduleReconnect() {
    state.reconnectTimer = setTimeout(connect, state.reconnectDelay);
    state.reconnectDelay = Math.min(state.reconnectDelay * 2, 15000);
  }

  function handleMessage(msg) {
    switch (msg.type) {
      case 'display.add':
        addCard(msg.card);
        break;
      case 'display.clear':
        handleClear(msg.keep_pinned);
        break;
      case 'display.section':
        addSection(msg.title, msg.run_id);
        break;
      case 'display.update':
        updateCard(msg.card_id, msg.changes);
        break;
    }
  }

  // --- Card Rendering ---
  function addCard(cardData) {
    // Remove empty state if present
    var empty = document.getElementById('empty-state');
    if (empty && empty.parentNode) {
      empty.remove();
    }

    // Deduplicate on reconnect replay
    var existing = document.getElementById('card-' + cardData.card_id);
    if (existing) return;

    state.cards.push(cardData);
    trackRunId(cardData.run_id);

    var el = document.createElement('div');
    el.className = 'card';
    if (cardData.pinned) el.className += ' pinned';
    el.id = 'card-' + cardData.card_id;
    el.dataset.runId = cardData.run_id || '';
    el.dataset.cardId = cardData.card_id;

    // Header
    var header = document.createElement('div');
    header.className = 'card-header';

    // Collapse toggle
    var collapseBtn = document.createElement('button');
    collapseBtn.className = 'card-collapse-btn';
    collapseBtn.innerHTML = '&#9660;';
    collapseBtn.title = 'Collapse';
    collapseBtn.onclick = function() {
      var body = el.querySelector('.card-body');
      var prov = el.querySelector('.card-provenance');
      var isCollapsed = collapseBtn.classList.toggle('collapsed');
      if (body) body.classList.toggle('collapsed', isCollapsed);
      if (prov) prov.classList.toggle('collapsed', isCollapsed);
      collapseBtn.title = isCollapsed ? 'Expand' : 'Collapse';
    };
    header.appendChild(collapseBtn);

    // Title
    var title = document.createElement('span');
    title.className = 'card-title';
    title.textContent = cardData.title || cardData.card_type;
    header.appendChild(title);

    // Timestamp
    var meta = document.createElement('span');
    meta.className = 'card-meta';
    if (cardData.timestamp) {
      meta.textContent = new Date(cardData.timestamp).toLocaleTimeString();
    }
    header.appendChild(meta);

    // Action buttons
    var actions = document.createElement('div');
    actions.className = 'card-actions';

    // Copy button
    var copyBtn = document.createElement('button');
    copyBtn.className = 'card-action-btn';
    copyBtn.innerHTML = '&#128203;';
    copyBtn.title = 'Copy content';
    copyBtn.onclick = function(e) {
      e.stopPropagation();
      copyCardContent(cardData, copyBtn);
    };
    actions.appendChild(copyBtn);

    // Pin button
    var pinBtn = document.createElement('button');
    pinBtn.className = 'card-action-btn' + (cardData.pinned ? ' pinned' : '');
    pinBtn.innerHTML = '&#128204;';
    pinBtn.title = cardData.pinned ? 'Unpin' : 'Pin (survives clear)';
    pinBtn.onclick = function(e) {
      e.stopPropagation();
      cardData.pinned = !cardData.pinned;
      pinBtn.classList.toggle('pinned', cardData.pinned);
      el.classList.toggle('pinned', cardData.pinned);
      el.dataset.pinned = cardData.pinned ? 'true' : 'false';
      pinBtn.title = cardData.pinned ? 'Unpin' : 'Pin (survives clear)';
    };
    actions.appendChild(pinBtn);

    header.appendChild(actions);
    el.appendChild(header);

    // Body
    var body = document.createElement('div');
    body.className = 'card-body';

    switch (cardData.card_type) {
      case 'table':
        renderTable(body, cardData);
        break;
      case 'plotly':
        renderPlotly(body, cardData);
        break;
      case 'image':
        renderImage(body, cardData);
        break;
      case 'markdown':
        renderMarkdown(body, cardData);
        break;
      case 'keyvalue':
        renderKeyValue(body, cardData);
        break;
      case 'section':
        el.remove();
        addSection(cardData.title || (cardData.preview && cardData.preview.title) || '');
        return;
      default:
        body.textContent = JSON.stringify(cardData.preview);
    }

    el.appendChild(body);

    // Provenance
    if (cardData.provenance) {
      var prov = document.createElement('div');
      prov.className = 'card-provenance';
      var parts = [];
      if (cardData.provenance.source) parts.push(cardData.provenance.source);
      if (cardData.provenance.dataset) parts.push(cardData.provenance.dataset);
      if (cardData.provenance.timestamp) {
        parts.push(new Date(cardData.provenance.timestamp).toLocaleString());
      }
      prov.textContent = parts.join(' \u00b7 ');
      if (parts.length > 0) el.appendChild(prov);
    }

    feed.appendChild(el);

    // Apply run filter to the new card
    if (state.activeRunFilter) {
      var cardRun = cardData.run_id || '';
      if (cardRun !== state.activeRunFilter && cardRun) {
        el.classList.add('hidden-by-filter');
      }
    }

    updateCardCount();
    scrollToBottom();
  }

  function copyCardContent(cardData, btn) {
    var text = '';
    if (cardData.card_type === 'markdown') {
      text = (cardData.preview && cardData.preview.text) || '';
    } else if (cardData.card_type === 'keyvalue') {
      var items = (cardData.preview && cardData.preview.items) || {};
      text = Object.keys(items).map(function(k) { return k + ': ' + items[k]; }).join('\n');
    } else if (cardData.card_type === 'table') {
      var p = cardData.preview;
      if (p && p.columns) {
        text = p.columns.join('\t') + '\n';
        (p.preview_rows || []).forEach(function(row) {
          text += row.map(function(v) { return v === null ? '' : String(v); }).join('\t') + '\n';
        });
      }
    } else if (cardData.card_type === 'plotly') {
      text = JSON.stringify(cardData.preview && cardData.preview.spec, null, 2);
    } else if (cardData.card_type === 'image') {
      // For images, copy the artifact URL so it can be opened/embedded
      text = cardData.artifact_id
        ? location.origin + '/api/artifact/' + cardData.artifact_id
        : '(no artifact)';
    } else {
      text = JSON.stringify(cardData.preview, null, 2);
    }

    navigator.clipboard.writeText(text).then(function() {
      btn.classList.add('copied');
      btn.innerHTML = '&#10003;';
      showToast('Copied to clipboard');
      setTimeout(function() {
        btn.classList.remove('copied');
        btn.innerHTML = '&#128203;';
      }, 1500);
    }).catch(function() {});
  }

  function showToast(msg) {
    copyToastEl.textContent = msg;
    copyToastEl.classList.add('visible');
    setTimeout(function() {
      copyToastEl.classList.remove('visible');
    }, 1500);
  }

  function renderTable(container, cardData) {
    var preview = cardData.preview;
    if (!preview || !preview.columns) return;

    var wrapper = document.createElement('div');
    wrapper.className = 'table-wrapper';

    var table = document.createElement('table');
    var thead = document.createElement('thead');
    var headerRow = document.createElement('tr');

    // Sort state for this table
    var sortState = { col: null, asc: true };

    preview.columns.forEach(function(col) {
      var th = document.createElement('th');
      var isNumeric = false;
      if (preview.dtypes) {
        var dtype = preview.dtypes[col] || '';
        if (dtype.match(/int|float|num/i)) {
          th.style.textAlign = 'right';
          isNumeric = true;
        }
      }

      var label = document.createTextNode(col);
      th.appendChild(label);

      var indicator = document.createElement('span');
      indicator.className = 'sort-indicator';
      indicator.textContent = '\u2195';
      th.appendChild(indicator);

      // Only enable server-side sort if there's an artifact to query
      if (cardData.artifact_id) {
        th.onclick = function() {
          if (sortState.col === col) {
            sortState.asc = !sortState.asc;
          } else {
            sortState.col = col;
            sortState.asc = true;
          }
          // Update indicators
          headerRow.querySelectorAll('.sort-indicator').forEach(function(ind) {
            ind.classList.remove('active');
            ind.textContent = '\u2195';
          });
          indicator.classList.add('active');
          indicator.textContent = sortState.asc ? '\u25b2' : '\u25bc';
          // Reload from server with sort
          loadSortedPage(cardData.artifact_id, 0, 50, sortState.col, sortState.asc, wrapper, preview.columns, preview.dtypes, preview.shape ? preview.shape[0] : 0, rowInfoEl, pagerState);
        };
      }

      headerRow.appendChild(th);
    });

    thead.appendChild(headerRow);
    table.appendChild(thead);

    var tbody = document.createElement('tbody');
    var rows = preview.preview_rows || [];
    renderTableRows(tbody, rows, preview.columns, preview.dtypes);

    table.appendChild(tbody);
    wrapper.appendChild(table);

    // Table info & pagination
    var shape = preview.shape || [0, 0];
    var totalRows = shape[0];
    var previewCount = rows.length;

    var info = document.createElement('div');
    info.className = 'table-info';

    var rowInfoEl = document.createElement('span');
    var rowInfoText = shape[1] + ' columns \u00b7 ' + totalRows.toLocaleString() + ' rows';
    if (previewCount < totalRows) {
      rowInfoText += ' (showing 1\u2013' + previewCount + ')';
    }
    rowInfoEl.textContent = rowInfoText;
    info.appendChild(rowInfoEl);

    // Pager state object for sharing between sort and pagination
    var pagerState = { offset: 0, limit: 50 };

    // Pager (only if more rows exist)
    if (totalRows > previewCount && cardData.artifact_id) {
      var pager = createPager(cardData.artifact_id, totalRows, preview.columns, preview.dtypes, wrapper, rowInfoEl, pagerState, sortState);
      info.appendChild(pager);
    }

    container.appendChild(wrapper);
    container.appendChild(info);
  }

  function renderTableRows(tbody, rows, columns, dtypes) {
    tbody.innerHTML = '';
    rows.forEach(function(row) {
      var tr = document.createElement('tr');
      row.forEach(function(val, i) {
        var td = document.createElement('td');
        td.textContent = val === null ? '\u2014' : String(val);
        if (dtypes) {
          var dtype = dtypes[columns[i]] || '';
          if (dtype.match(/int|float|num/i)) {
            td.style.textAlign = 'right';
          }
        }
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    });
  }

  function loadSortedPage(artifactId, offset, limit, sortCol, sortAsc, wrapper, columns, dtypes, totalRows, rowInfoEl, pagerState) {
    var url = '/api/table/' + artifactId + '?offset=' + offset + '&limit=' + limit;
    if (sortCol) {
      url += '&sort=' + encodeURIComponent(sortCol) + '&asc=' + sortAsc;
    }
    fetch(url)
      .then(function(r) { return r.json(); })
      .then(function(data) {
        var tbody = wrapper.querySelector('tbody');
        renderTableRows(tbody, data.rows, columns, dtypes);
        if (pagerState) pagerState.offset = offset;
        var end = Math.min(offset + limit, totalRows);
        rowInfoEl.textContent = columns.length + ' columns \u00b7 ' + totalRows.toLocaleString() + ' rows (showing ' + (offset + 1) + '\u2013' + end + ')';
      });
  }

  function createPager(artifactId, totalRows, columns, dtypes, wrapper, rowInfoEl, pagerState, sortState) {
    var limit = pagerState.limit;

    var pager = document.createElement('div');
    pager.className = 'table-pager';

    var prevBtn = document.createElement('button');
    prevBtn.textContent = '\u2190 Prev';
    prevBtn.disabled = true;

    var pageInfo = document.createElement('span');

    var nextBtn = document.createElement('button');
    nextBtn.textContent = 'Next \u2192';

    function updatePage() {
      var start = pagerState.offset + 1;
      var end = Math.min(pagerState.offset + limit, totalRows);
      pageInfo.textContent = start + '\u2013' + end + ' of ' + totalRows.toLocaleString();
      prevBtn.disabled = pagerState.offset === 0;
      nextBtn.disabled = pagerState.offset + limit >= totalRows;
      rowInfoEl.textContent = columns.length + ' columns \u00b7 ' + totalRows.toLocaleString() + ' rows (showing ' + start + '\u2013' + end + ')';
    }

    function loadPage() {
      var url = '/api/table/' + artifactId + '?offset=' + pagerState.offset + '&limit=' + limit;
      if (sortState && sortState.col) {
        url += '&sort=' + encodeURIComponent(sortState.col) + '&asc=' + sortState.asc;
      }
      fetch(url)
        .then(function(r) { return r.json(); })
        .then(function(data) {
          var tbody = wrapper.querySelector('tbody');
          renderTableRows(tbody, data.rows, columns, dtypes);
          updatePage();
        });
    }

    prevBtn.onclick = function() {
      pagerState.offset = Math.max(0, pagerState.offset - limit);
      loadPage();
    };

    nextBtn.onclick = function() {
      pagerState.offset = pagerState.offset + limit;
      loadPage();
    };

    pager.appendChild(prevBtn);
    pager.appendChild(pageInfo);
    pager.appendChild(nextBtn);
    updatePage();

    return pager;
  }

  function renderMarkdown(container, cardData) {
    var text = (cardData.preview && cardData.preview.text) || '';
    container.className += ' markdown-body';

    if (window.marked) {
      container.innerHTML = window.marked.parse(text);
    } else {
      container.innerHTML = basicMarkdown(text);
      loadMarked(function() {
        container.innerHTML = window.marked.parse(text);
      });
    }
  }

  function basicMarkdown(text) {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/^### (.+)$/gm, '<h3>$1</h3>')
      .replace(/^## (.+)$/gm, '<h2>$1</h2>')
      .replace(/^# (.+)$/gm, '<h1>$1</h1>')
      .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.+?)\*/g, '<em>$1</em>')
      .replace(/`([^`]+)`/g, '<code>$1</code>')
      .replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
      .replace(/\n\n/g, '</p><p>')
      .replace(/\n/g, '<br>')
      .replace(/^/, '<p>')
      .replace(/$/, '</p>');
  }

  function loadMarked(callback) {
    if (state.markedLoaded) return;
    state.markedLoaded = true;

    var script = document.createElement('script');
    script.src = '/static/vendor/marked.min.js';
    script.onload = function() {
      if (window.marked) {
        window.marked.setOptions({ breaks: true, gfm: true });
        if (callback) callback();
      }
    };
    script.onerror = function() {
      state.markedLoaded = false;
    };
    document.head.appendChild(script);
  }

  function renderKeyValue(container, cardData) {
    var items = (cardData.preview && cardData.preview.items) || {};
    var dl = document.createElement('div');
    dl.className = 'kv-list';

    Object.keys(items).forEach(function(key) {
      var keyEl = document.createElement('div');
      keyEl.className = 'kv-key';
      keyEl.textContent = key;

      var valEl = document.createElement('div');
      valEl.className = 'kv-value';
      valEl.textContent = items[key];

      dl.appendChild(keyEl);
      dl.appendChild(valEl);
    });

    container.appendChild(dl);
  }

  // --- Plotly Charts ---

  function renderPlotly(container, cardData) {
    var spec = cardData.preview && cardData.preview.spec;
    if (!spec) {
      container.textContent = 'No chart data';
      return;
    }

    var plotDiv = document.createElement('div');
    plotDiv.className = 'plotly-container';
    plotDiv.id = 'plotly-' + cardData.card_id;
    container.appendChild(plotDiv);

    function doRender() {
      var data = spec.data || [];
      var layout = Object.assign({}, spec.layout || {}, {
        autosize: true,
        margin: { l: 50, r: 30, t: 40, b: 50 },
        paper_bgcolor: 'transparent',
        plot_bgcolor: 'transparent',
        font: { color: getComputedStyle(document.documentElement).getPropertyValue('--text').trim() },
      });
      var config = { responsive: true, displayModeBar: true, displaylogo: false };

      window.Plotly.newPlot(plotDiv, data, layout, config).then(function() {
        // Attach point selection event
        plotDiv.on('plotly_selected', function(eventData) {
          if (eventData && state.ws && state.connected) {
            var points = (eventData.points || []).map(function(pt) {
              return { x: pt.x, y: pt.y, pointIndex: pt.pointIndex, curveNumber: pt.curveNumber };
            });
            state.ws.send(JSON.stringify({
              type: 'display.event',
              event_type: 'point_select',
              card_id: cardData.card_id,
              payload: { points: points },
            }));
          }
        });

        plotDiv.on('plotly_click', function(eventData) {
          if (eventData && state.ws && state.connected) {
            var points = (eventData.points || []).map(function(pt) {
              return { x: pt.x, y: pt.y, pointIndex: pt.pointIndex, curveNumber: pt.curveNumber };
            });
            state.ws.send(JSON.stringify({
              type: 'display.event',
              event_type: 'point_click',
              card_id: cardData.card_id,
              payload: { points: points },
            }));
          }
        });
      });
    }

    if (window.Plotly) {
      doRender();
    } else {
      // Show loading indicator
      var loading = document.createElement('div');
      loading.className = 'chart-loading';
      loading.textContent = 'Loading chart library...';
      plotDiv.appendChild(loading);

      loadPlotly(function() {
        plotDiv.removeChild(loading);
        doRender();
      });
    }
  }

  function loadPlotly(callback) {
    if (window.Plotly) {
      if (callback) callback();
      return;
    }

    // Queue callbacks if already loading
    if (state.plotlyLoaded) {
      state.plotlyCallbacks.push(callback);
      return;
    }
    state.plotlyLoaded = true;
    state.plotlyCallbacks.push(callback);

    var script = document.createElement('script');
    script.src = '/static/vendor/plotly.min.js';
    script.onload = function() {
      var cbs = state.plotlyCallbacks;
      state.plotlyCallbacks = [];
      cbs.forEach(function(cb) { if (cb) cb(); });
    };
    script.onerror = function() {
      state.plotlyLoaded = false;
      var cbs = state.plotlyCallbacks;
      state.plotlyCallbacks = [];
      cbs.forEach(function(cb) {
        // Attempt fallback: render as static image if artifact exists
      });
    };
    document.head.appendChild(script);
  }

  // Resize Plotly charts on window resize
  window.addEventListener('resize', function() {
    if (!window.Plotly) return;
    var plots = document.querySelectorAll('.plotly-container .js-plotly-plot');
    plots.forEach(function(plot) {
      window.Plotly.Plots.resize(plot);
    });
  });

  // Re-color Plotly charts on theme change
  var _origThemeToggle = themeToggleEl.onclick;
  themeToggleEl.onclick = function() {
    _origThemeToggle.call(this);
    if (!window.Plotly) return;
    var textColor = getComputedStyle(document.documentElement).getPropertyValue('--text').trim();
    var plots = document.querySelectorAll('.plotly-container .js-plotly-plot');
    plots.forEach(function(plot) {
      window.Plotly.relayout(plot, {
        'paper_bgcolor': 'transparent',
        'plot_bgcolor': 'transparent',
        'font.color': textColor,
      });
    });
  };

  // --- Image Cards (matplotlib SVG) ---

  function renderImage(container, cardData) {
    var preview = cardData.preview || {};
    var imgContainer = document.createElement('div');
    imgContainer.className = 'image-container';

    var img = document.createElement('img');

    if (preview.data && preview.format === 'svg') {
      img.src = 'data:image/svg+xml;base64,' + preview.data;
    } else if (preview.data && preview.format === 'png') {
      img.src = 'data:image/png;base64,' + preview.data;
    } else if (cardData.artifact_id) {
      // Fall back to artifact endpoint
      img.src = '/api/artifact/' + cardData.artifact_id;
    } else {
      container.textContent = 'No image data';
      return;
    }

    img.alt = cardData.title || 'Figure';
    img.style.maxWidth = '100%';
    imgContainer.appendChild(img);
    container.appendChild(imgContainer);
  }

  function addSection(title, runId) {
    var empty = document.getElementById('empty-state');
    if (empty && empty.parentNode) {
      empty.remove();
    }

    if (runId) trackRunId(runId);

    var div = document.createElement('div');
    div.className = 'section-divider';
    div.textContent = title;
    div.dataset.runId = runId || '';
    feed.appendChild(div);

    if (state.activeRunFilter) {
      applyRunFilter();
    }

    scrollToBottom();
  }

  function updateCard(cardId, changes) {
    // Future: handle card updates (replace=)
  }

  function handleClear(keepPinned) {
    var items = feed.querySelectorAll('.card, .section-divider');
    items.forEach(function(el) {
      if (keepPinned && el.dataset && el.dataset.pinned === 'true') return;
      el.remove();
    });

    state.cards = keepPinned
      ? state.cards.filter(function(c) { return c.pinned; })
      : [];

    // Rebuild run filter
    rebuildRunFilter();
    updateCardCount();

    if (state.cards.length === 0) {
      showEmptyState();
    }
  }

  function rebuildRunFilter() {
    var runs = [];
    state.cards.forEach(function(c) {
      if (c.run_id && runs.indexOf(c.run_id) === -1) runs.push(c.run_id);
    });
    state.runIds = runs;

    var currentFilter = runFilterEl.value;
    runFilterEl.innerHTML = '<option value="">All runs</option>';
    runs.forEach(function(rid) {
      var opt = document.createElement('option');
      opt.value = rid;
      opt.textContent = rid;
      runFilterEl.appendChild(opt);
    });

    if (runs.indexOf(currentFilter) !== -1) {
      runFilterEl.value = currentFilter;
    } else {
      runFilterEl.value = '';
      state.activeRunFilter = '';
    }
  }

  function showEmptyState() {
    var existing = document.getElementById('empty-state');
    if (existing) return;

    var empty = document.createElement('div');
    empty.className = 'empty-state';
    empty.id = 'empty-state';
    empty.innerHTML = '<div style="font-size: 32px; opacity: 0.3;">&#9671;</div>'
      + '<div>Waiting for data...</div>'
      + '<div><code>from m4.display import show</code></div>';
    feed.appendChild(empty);
  }

  // --- Actions ---
  window.clearCards = function() {
    fetch('/api/clear', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ keep_pinned: true }),
    });
  };

  // --- UI Helpers ---
  function updateStatus(status) {
    var dotClass = status === 'connected' ? 'status-connected'
      : status === 'disconnected' ? 'status-disconnected'
      : 'status-connecting';
    var label = status.charAt(0).toUpperCase() + status.slice(1);
    statusEl.innerHTML = '<span class="status-dot ' + dotClass + '"></span> ' + label;
  }

  function updateCardCount() {
    var all = feed.querySelectorAll('.card');
    var visible = 0;
    all.forEach(function(el) {
      if (!el.classList.contains('hidden-by-filter')) visible++;
    });
    var text = visible + ' card' + (visible !== 1 ? 's' : '');
    if (visible !== all.length) {
      text += ' (of ' + all.length + ')';
    }
    cardCountEl.textContent = text;
  }

  function loadSessionInfo() {
    fetch('/api/session')
      .then(function(r) { return r.json(); })
      .then(function(data) {
        var sid = (data.session_id || '').substring(0, 8);
        sessionInfoEl.textContent = sid ? 'session: ' + sid : '';
      })
      .catch(function() {});
  }

  function scrollToBottom() {
    requestAnimationFrame(function() {
      window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
    });
  }

  // --- Init ---
  connect();
})();
</script>
</body>
</html>
